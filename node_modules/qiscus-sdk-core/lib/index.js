"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _superagent = _interopRequireDefault(require("superagent"));

var _mitt = _interopRequireDefault(require("mitt"));

var _is_js = _interopRequireDefault(require("is_js"));

var _format = _interopRequireDefault(require("date-fns/format"));

var _distance_in_words_to_now = _interopRequireDefault(require("date-fns/distance_in_words_to_now"));

var _Comment = _interopRequireDefault(require("./lib/Comment"));

var _Room = _interopRequireDefault(require("./lib/Room"));

var _http = _interopRequireDefault(require("./lib/adapters/http"));

var _auth = _interopRequireDefault(require("./lib/adapters/auth"));

var _user = _interopRequireDefault(require("./lib/adapters/user"));

var _room = _interopRequireDefault(require("./lib/adapters/room"));

var _mqtt = _interopRequireDefault(require("./lib/adapters/mqtt"));

var _customEvent = _interopRequireDefault(require("./lib/adapters/custom-event"));

var _sync = _interopRequireDefault(require("./lib/adapters/sync"));

var _utils = require("./lib/utils");

var _util = require("./lib/util");

var _package = _interopRequireDefault(require("../package.json"));

var _hook = require("./lib/adapters/hook");

var _expiredToken = require("./lib/adapters/expired-token");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

// helper for setup publishOnlinePresence status
var setBackToOnline;
var UpdateCommentStatusMode = Object.freeze({
  disabled: 'UpdateCommentStatusMode.disabled',
  throttled: 'UpdateCommentStatusMode.throttled',
  enabled: 'UpdateCommentStatusMode.enabled'
});
/**
 * Qiscus Web SDK Core Class
 *
 * @export
 * @class QiscusSDK
 */

var QiscusSDK = /*#__PURE__*/function () {
  /**
   * Creates an instance of QiscusSDK.
   */
  function QiscusSDK() {
    var _this = this;

    (0, _classCallCheck2["default"])(this, QiscusSDK);
    (0, _defineProperty2["default"])(this, "_readComment", function (roomId, commentId) {
      return _this._updateStatus(roomId, commentId);
    });
    (0, _defineProperty2["default"])(this, "_readCommentT", this._throttle(function (roomId, commentId) {
      _this._updateStatus(roomId, commentId);
    }, function () {
      return _this._throttleDelay;
    }));
    (0, _defineProperty2["default"])(this, "_deliverComment", function (roomId, commentId) {
      return _this._updateStatus(roomId, undefined, commentId);
    });
    (0, _defineProperty2["default"])(this, "_deliverCommentT", this._throttle(function (roomId, commentId) {
      _this._updateStatus(roomId, undefined, commentId);
    }, function () {
      return _this._throttleDelay;
    }));
    this.events = (0, _mitt["default"])();
    this.rooms = [];
    this.selected = null;
    this.room_name_id_map = {};
    this.pendingCommentId = 0;
    this.uploadedFiles = [];
    this.chatmateStatus = null;
    this.version = "WEB_".concat(_package["default"].version);
    this.userData = {}; // SDK Configuration

    this.AppId = null;
    this.baseURL = 'https://api.qiscus.com';
    this.mqttURL = 'wss://realtime-jogja.qiscus.com:1886/mqtt';
    this.brokerLbUrl = 'https://realtime-lb.qiscus.com';
    this.syncOnConnect = 10000;
    this.enableEventReport = false;
    this.enableRealtime = true;
    this.enableRealtimeCheck = true;
    this.enableSync = true;
    this.enableSyncEvent = false;
    this.HTTPAdapter = null;
    this.expiredTokenAdapter = null;
    this.realtimeAdapter = null;
    this.customEventAdapter = null;
    this.isInit = false;
    this.isSynced = false;
    this.syncInterval = 5000;
    this.sync = 'socket'; // possible values 'socket', 'http', 'both'

    this.enableLb = true;
    this.httpsync = null;
    this.eventsync = null;
    this.extras = null;
    this.last_received_comment_id = 0;
    this.googleMapKey = '';
    this.options = {
      avatar: true
    };
    this.isConfigLoaded = false;
    this.updateCommentStatusMode = QiscusSDK.UpdateCommentStatusMode.enabled;
    this.updateCommentStatusThrottleDelay = 300; // UI related Properties

    this.UI = {};
    this.mode = 'widget';
    this.avatar = true;
    this.plugins = [];
    this.isLogin = false;
    this.isLoading = false;
    this.isInit = false;
    this.emoji = false;
    this.isTypingStatus = '';
    this.customTemplate = false;
    this.templateFunction = null;
    this.debugMode = false;
    this.debugMQTTMode = false;
    this._customHeader = {};
    this._forceEnableSync = true; // to prevent double receive newmessages callback

    this.lastReceiveMessages = [];
    this._hookAdapter = (0, _hook.hookAdapterFactory)();
    this._uploadURL = null;
    this._autoRefreshToken = false;
  } // this.uploadURL = `${this.baseURL}/api/v2/sdk/upload`


  (0, _createClass2["default"])(QiscusSDK, [{
    key: "init",

    /**
     * Initializing the SDK, set Event Listeners (callbacks)
     * @param {any} config - Qiscus SDK Configurations
     * @return {Promise<void>}
     */
    value: function () {
      var _init = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3(config) {
        var _this2 = this,
            _config$withConfig;

        var isDifferentBaseUrl, isDifferentMqttUrl, isDifferentBrokerLbUrl, setterHelper, mqttWssCheck;
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (config.AppId) {
                  _context3.next = 2;
                  break;
                }

                throw new Error('Please provide valid AppId');

              case 2:
                this.AppId = config.AppId; // We need to disable realtime load balancing if user are using custom server
                // and did not provide a brokerLbUrl

                isDifferentBaseUrl = config.baseURL != null && this.baseURL !== config.baseURL;
                isDifferentMqttUrl = config.mqttURL != null && this.mqttURL !== config.mqttURL;
                isDifferentBrokerLbUrl = config.brokerLbURL != null && this.brokerLbUrl !== config.brokerLbURL; // disable realtime lb if user change baseUrl or mqttUrl but did not change
                // broker lb url

                if ((isDifferentBaseUrl || isDifferentMqttUrl) && !isDifferentBrokerLbUrl) {
                  this.logger('' + 'force disable load balancing for realtime server, because ' + '`baseURL` or `mqttURL` get changed but ' + 'did not provide `brokerLbURL`');
                  this.enableLb = false;
                } else if (config.enableRealtimeLB != null) {
                  this.enableLb = config.enableRealtimeLB;
                }

                if (config.updateCommentStatusMode != null) this.updateCommentStatusMode = config.updateCommentStatusMode;
                if (config.updateCommentStatusThrottleDelay != null) this.updateCommentStatusThrottleDelay = config.updateCommentStatusThrottleDelay;
                if (config.baseURL) this.baseURL = config.baseURL;
                if (config.mqttURL) this.mqttURL = config.brokerUrl || config.mqttURL;
                if (config.mqttURL) this.brokerUrl = config.brokerUrl || config.mqttURL;
                if (config.brokerLbURL) this.brokerLbUrl = config.brokerLbURL;
                if (config.uploadURL) this.uploadURL = config.uploadURL;
                if (config.sync) this.sync = config.sync;
                if (config.mode) this.mode = config.mode;
                if (config.syncInterval) this.syncInterval = config.syncInterval || 5000;
                if (config.googleMapKey) this.googleMapKey = config.googleMapKey;

                if (config.allowedFileTypes) {
                  this.allowedFileTypes = config.allowedFileTypes;
                } // Let's initialize the app based on options


                if (config.options) {
                  this.options = Object.assign({}, this.options, config.options);
                }

                if (config.customTemplate) this.customTemplate = config.customTemplate;

                if (config.templateFunction) {
                  this.templateFunction = config.templateFunction;
                }

                if (config.syncInterval != null) this.syncInterval = config.syncInterval; // this._customHeader = {}
                // set appConfig

                this.HTTPAdapter = new _http["default"]({
                  baseURL: this.baseURL,
                  AppId: this.AppId,
                  userId: this.user_id,
                  version: this.version,
                  getCustomHeader: function getCustomHeader() {
                    return _this2._customHeader;
                  }
                });
                /**
                 * @callback SetterCallback
                 * @param {string | number} value
                 * @return void
                 */

                /**
                 * @typedef {string | number | boolean | null} Parameter
                 */

                /**
                 *
                 * @param {Parameter} fromUser
                 * @param {Parameter} fromServer
                 * @param {Parameter} defaultValue
                 * @return {Parameter}
                 */

                setterHelper = function setterHelper(fromUser, fromServer, defaultValue) {
                  if (fromServer === '') {
                    if (fromUser != null) {
                      if (typeof fromUser !== 'string') return fromUser;
                      if (fromUser.length > 0) return fromUser;
                    }
                  }

                  if (fromServer != null) {
                    if (fromServer.length > 0) return fromServer;
                    if (typeof fromServer !== 'string') return fromServer;
                  }

                  return defaultValue;
                };

                mqttWssCheck = function mqttWssCheck(mqttResult) {
                  if (mqttResult.includes('wss://')) {
                    return mqttResult;
                  } else {
                    return "wss://".concat(mqttResult, ":1886/mqtt");
                  }
                };

                this.withConfig = (_config$withConfig = config.withConfig) !== null && _config$withConfig !== void 0 ? _config$withConfig : true;

                if (!(this.withConfig === true)) {
                  _context3.next = 32;
                  break;
                }

                _context3.next = 30;
                return this.HTTPAdapter.get_request('api/v2/sdk/config').then(function (resp) {
                  resp.status == 200 ? _this2.isConfigLoaded = true : _this2.isConfigLoaded = false;
                  return resp.body.results;
                }).then(function (cfg) {
                  var baseUrl = _this2.baseURL; // default value for baseUrl

                  var brokerLbUrl = _this2.brokerLbUrl; // default value for brokerLbUrl

                  var mqttUrl = _this2.mqttURL; // default value for brokerUrl

                  var enableRealtime = _this2.enableRealtime; // default value for enableRealtime

                  var enableRealtimeCheck = _this2.enableRealtimeCheck; // default value for enableRealtimeCheck

                  var syncInterval = _this2.syncInterval; // default value for syncInterval

                  var syncIntervalWhenConnected = _this2.syncOnConnect; // default value for syncIntervalWhenConnected

                  var enableEventReport = _this2.enableEventReport; // default value for enableEventReport

                  var configExtras = {}; // default value for extras

                  _this2.baseURL = setterHelper(config.baseURL, cfg.base_url, baseUrl);
                  _this2.brokerLbUrl = setterHelper(config.brokerLbURL, cfg.broker_lb_url, brokerLbUrl);
                  _this2.mqttURL = mqttWssCheck(setterHelper(config.mqttURL, cfg.broker_url, mqttUrl));
                  _this2.enableRealtime = setterHelper(config.enableRealtime, cfg.enable_realtime, enableRealtime);
                  _this2.syncInterval = setterHelper(config.syncInterval, cfg.sync_interval, syncInterval);
                  _this2.syncOnConnect = setterHelper(config.syncOnConnect, cfg.sync_on_connect, syncIntervalWhenConnected); // since user never provide this value

                  _this2.enableRealtimeCheck = setterHelper(null, cfg.enable_realtime_check, enableRealtimeCheck);
                  _this2.enableEventReport = setterHelper(null, cfg.enable_event_report, enableEventReport);
                  _this2.extras = setterHelper(null, cfg.extras, configExtras);
                  _this2.enableSync = setterHelper(null, cfg.enable_sync, _this2.enableSync);
                  _this2.enableSyncEvent = setterHelper(null, cfg.enable_sync_event, _this2.enableSyncEvent);
                  _this2._autoRefreshToken = setterHelper(null, cfg.auto_refresh_token, false);
                })["catch"](function (err) {
                  _this2.logger('got error when trying to get app config', err);

                  _this2.isConfigLoaded = true;
                });

              case 30:
                _context3.next = 33;
                break;

              case 32:
                this.isConfigLoaded = true;

              case 33:
                // set Event Listeners
                this._getMqttClientId = function () {
                  return "".concat(_this2.AppId, "_").concat(_this2.user_id, "_").concat(Date.now());
                };

                this.realtimeAdapter = new _mqtt["default"](this.mqttURL, this, this.isLogin, {
                  brokerLbUrl: this.brokerLbUrl,
                  enableLb: this.enableLb,
                  shouldConnect: this.enableRealtime,
                  getClientId: this._getMqttClientId
                });
                this.realtimeAdapter.on('connected', function () {
                  if (_this2.isLogin || !_this2.realtimeAdapter.connected) {
                    _this2.last_received_comment_id = _this2.userData.last_comment_id;

                    _this2.updateLastReceivedComment(_this2.last_received_comment_id);
                  }
                });
                this.realtimeAdapter.on('close', function () {});
                this.realtimeAdapter.on('reconnect', function () {
                  var _this2$options$onReco, _this2$options;

                  (_this2$options$onReco = (_this2$options = _this2.options).onReconnectCallback) === null || _this2$options$onReco === void 0 ? void 0 : _this2$options$onReco.call(_this2$options);
                });
                this.realtimeAdapter.on('message-delivered', function (_ref) {
                  var commentId = _ref.commentId,
                      commentUniqueId = _ref.commentUniqueId,
                      userId = _ref.userId;
                  return _this2._setDelivered(commentId, commentUniqueId, userId);
                });
                this.realtimeAdapter.on('message-read', function (_ref2) {
                  var commentId = _ref2.commentId,
                      commentUniqueId = _ref2.commentUniqueId,
                      userId = _ref2.userId;
                  return _this2._setRead(commentId, commentUniqueId, userId);
                });
                this.realtimeAdapter.on('new-message', /*#__PURE__*/function () {
                  var _ref3 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(message) {
                    return _regenerator["default"].wrap(function _callee$(_context) {
                      while (1) {
                        switch (_context.prev = _context.next) {
                          case 0:
                            _context.next = 2;
                            return _this2._hookAdapter.trigger(_hook.Hooks.MESSAGE_BEFORE_RECEIVED, message);

                          case 2:
                            message = _context.sent;

                            _this2.events.emit('newmessages', [message]);

                          case 4:
                          case "end":
                            return _context.stop();
                        }
                      }
                    }, _callee);
                  }));

                  return function (_x2) {
                    return _ref3.apply(this, arguments);
                  };
                }());
                this.realtimeAdapter.on('presence', function (data) {
                  return _this2.events.emit('presence', data);
                });
                this.realtimeAdapter.on('comment-deleted', function (data) {
                  return _this2.events.emit('comment-deleted', data);
                });
                this.realtimeAdapter.on('room-cleared', function (data) {
                  return _this2.events.emit('room-cleared', data);
                });
                this.realtimeAdapter.on('typing', function (data) {
                  return _this2.events.emit('typing', {
                    message: data.message,
                    username: data.userId,
                    room_id: data.roomId
                  });
                });
                this.realtimeAdapter.on('message:updated', function (message) {
                  if (_this2.options.messageUpdatedCallback != null) {
                    _this2.options.messageUpdatedCallback(message);
                  }
                });
                this.syncAdapter = (0, _sync["default"])(function () {
                  return _this2.HTTPAdapter;
                }, {
                  getToken: function getToken() {
                    return _this2.userData.token;
                  },
                  syncInterval: function syncInterval() {
                    return _this2.syncInterval;
                  },
                  getShouldSync: function getShouldSync() {
                    return _this2._forceEnableSync && _this2.isLogin && !_this2.realtimeAdapter.connected;
                  },
                  syncOnConnect: function syncOnConnect() {
                    return _this2.syncOnConnect;
                  },
                  lastCommentId: function lastCommentId() {
                    return _this2.last_received_comment_id;
                  },
                  statusLogin: function statusLogin() {
                    return _this2.isLogin;
                  },
                  enableSync: function enableSync() {
                    return _this2.enableSync;
                  },
                  enableSyncEvent: function enableSyncEvent() {
                    return _this2.enableSyncEvent;
                  }
                });
                this.syncAdapter.on('message.new', /*#__PURE__*/function () {
                  var _ref4 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(message) {
                    var index, _message;

                    return _regenerator["default"].wrap(function _callee2$(_context2) {
                      while (1) {
                        switch (_context2.prev = _context2.next) {
                          case 0:
                            _context2.next = 2;
                            return _this2._hookAdapter.trigger(_hook.Hooks.MESSAGE_BEFORE_RECEIVED, message);

                          case 2:
                            message = _context2.sent;

                            if (_this2.selected != null) {
                              index = _this2.selected.comments.findIndex(function (it) {
                                return it.id === message.id || it.unique_id === message.unique_temp_id;
                              });

                              if (index === -1) {
                                _message = new _Comment["default"](message);

                                if (_message.room_id === _this2.selected.id) {
                                  _this2.selected.comments.push(_message);

                                  _this2.sortComments();
                                }

                                _this2.events.emit('newmessages', [message]);
                              }
                            } else {
                              _this2.events.emit('newmessages', [message]);
                            }

                          case 4:
                          case "end":
                            return _context2.stop();
                        }
                      }
                    }, _callee2);
                  }));

                  return function (_x3) {
                    return _ref4.apply(this, arguments);
                  };
                }());
                this.syncAdapter.on('message.delivered', function (message) {
                  _this2._setDelivered(message.comment_id, message.comment_unique_id, message.email);
                });
                this.syncAdapter.on('message.read', function (message) {
                  _this2._setRead(message.comment_id, message.comment_unique_id, message.email);
                });
                this.syncAdapter.on('message.deleted', function (data) {
                  data.deleted_messages.forEach(function (it) {
                    _this2.events.emit('comment-deleted', {
                      roomId: it.room_id,
                      commentUniqueIds: it.message_unique_ids,
                      isForEveryone: true,
                      isHard: true
                    });
                  });
                });
                this.syncAdapter.on('room.cleared', function (data) {
                  data.deleted_rooms.forEach(function (room) {
                    _this2.events.emit('room-cleared', room);
                  });
                });
                this.customEventAdapter = (0, _customEvent["default"])(this.realtimeAdapter, this.user_id);
                this.setEventListeners();

              case 54:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function init(_x) {
        return _init.apply(this, arguments);
      }

      return init;
    }()
  }, {
    key: "_setRead",
    value: function _setRead(messageId, messageUniqueId, userId) {
      if (this.selected == null) return;
      var room = this.selected;
      var message = room.comments.find(function (it) {
        return it.id === messageId || it.unique_id === messageUniqueId;
      });
      if (message == null) return;
      if (message.status === 'read') return;
      var options = {
        participants: room.participants,
        actor: userId,
        comment_id: messageId,
        activeActorId: this.user_id
      };
      room.comments.forEach(function (it) {
        if (it.id <= message.id) {
          it.markAsRead(options);
        }
      });
      if (!message.isRead) return;
      this.events.emit('comment-read', {
        comment: message,
        userId: userId
      });
    }
  }, {
    key: "_setDelivered",
    value: function _setDelivered(messageId, messageUniqueId, userId) {
      if (this.selected == null) return;
      var room = this.selected;
      var message = room.comments.find(function (it) {
        return it.id === messageId || it.unique_id === messageUniqueId;
      });
      if (message == null) return;
      if (message.status === 'read') return;
      var options = {
        participants: room.participants,
        actor: userId,
        comment_id: messageId,
        activeActorId: this.user_id
      };
      room.comments.forEach(function (it) {
        if (it.id <= message.id) {
          it.markAsDelivered(options);
        }
      });
      if (!message.isDelivered) return;
      this.events.emit('comment-delivered', {
        comment: message,
        userId: userId
      });
    }
  }, {
    key: "setEventListeners",
    value: function setEventListeners() {
      var _this3 = this;

      var self = this;
      this.authAdapter = new _auth["default"](self.HTTPAdapter);

      if (this.userData.email != null) {
        this.authAdapter.userId = this.userData.email;
      }

      self.events.on('start-init', function () {
        self.HTTPAdapter = new _http["default"]({
          baseURL: self.baseURL,
          AppId: self.AppId,
          userId: self.user_id,
          version: self.version,
          getCustomHeader: function getCustomHeader() {
            return _this3._customHeader;
          }
        });
        self.HTTPAdapter.setToken(self.userData.token);
      });
      self.events.on('room-changed', function (room) {
        _this3.logging('room changed', room);

        if (self.options.roomChangedCallback) {
          self.options.roomChangedCallback(room);
        }
      });
      self.events.on('file-uploaded', function (url) {
        if (self.options.fileUploadedCallback) {
          self.options.fileUploadedCallback(url);
        }
      });
      self.events.on('profile-updated', function (user) {
        self.username = user.name;
        self.avatar_url = user.avatar_url;

        if (self.options.updateProfileCallback) {
          self.options.updateProfileCallback(user);
        }
      });
      /**
       * This event will be called when there's new post messages
       * @param {string} data - JSON Response from SYNC API / MQTT
       * @return {void}
       */

      self.events.on('newmessages', function (comments) {
        // let's convert the data into something we can use
        // first we need to make sure we sort this data out based on room_id
        _this3.logging('newmessages', comments);

        var lastReceivedMessageNotEmpty = _this3.lastReceiveMessages.length > 0;

        if (lastReceivedMessageNotEmpty && _this3.lastReceiveMessages[0].unique_temp_id === comments[0].unique_temp_id) {
          _this3.logging('lastReceiveMessages double', comments);

          return;
        }

        _this3.lastReceiveMessages = comments;

        self._callNewMessagesCallback(comments);

        comments.forEach(function (comment) {
          // we have this comment, so means it's already delivered, update it's delivered status
          self.receiveComment(comment.room_id, comment.id);
          var isActiveRoom = self.selected ? comment.room_id === self.selected.id : false;
          var isAlreadyRead = comment.id <= self.last_received_comment_id; // kalau comment ini ada di currently selected

          if (isActiveRoom) {
            var selected = self.selected;
            var lastComment = self.selected.comments[self.selected.comments.length - 1]; // kirim event read kalau ini bukan komen kita sendiri

            if (!lastComment.isPending && !isAlreadyRead && self.user_id !== comment.email) {
              self.readComment(comment.room_id, comment.id);
            } // pastiin sync


            var roomLastCommentId = lastComment.id;
            var commentBeforeThis = self.selected.comments.find(function (c) {
              return c.id === lastComment.comment_before_id;
            });

            if (!lastComment.isPending && !commentBeforeThis) {
              _this3.logging('comment before id not found! ', comment.comment_before_id); // need to fix, these method does not work


              self.synchronize(roomLastCommentId);
            } // pastikan dulu komen ini komen baru, klo komen lama ga usah panggil cb


            var pendingComment = new _Comment["default"](comment); // fetch the comment inside the room

            selected.receiveComment(pendingComment);
            selected.last_comment_id = pendingComment.id;
            selected.last_comment_message = pendingComment.message;
          } // let's update last_received_comment_id


          self.updateLastReceivedComment(comment.id);

          _this3.sortComments();
        });
      });
      /**
       * This event will be called when login is sucess
       * Basically, it sets up necessary properties for qiscusSDK
       */

      this.events.on('login-success', function (response) {
        _this3.isLogin = true;
        _this3.userData = response.user;
        _this3.last_received_comment_id = _this3.userData.last_comment_id;
        if (!_this3.realtimeAdapter.connected) _this3.updateLastReceivedComment(_this3.last_received_comment_id); // now that we have the token, etc, we need to set all our adapters

        _this3.HTTPAdapter = new _http["default"]({
          baseURL: _this3.baseURL,
          AppId: _this3.AppId,
          userId: _this3.user_id,
          version: _this3.version,
          getCustomHeader: function getCustomHeader() {
            return _this3._customHeader;
          }
        });

        _this3.HTTPAdapter.setToken(_this3.userData.token);

        var user = response.user;
        _this3.expiredTokenAdapter = new _expiredToken.ExpiredTokenAdapter({
          httpAdapter: _this3.HTTPAdapter,
          refreshToken: user.refresh_token,
          expiredAt: user.token_expires_at,
          userId: _this3.user_id,
          onTokenRefreshed: function onTokenRefreshed(token, refreshToken, expiredAt) {
            _this3.userData.token = token;
            _this3.userData.refresh_token = refreshToken;
            _this3.userData.token_expires_at = expiredAt === null || expiredAt === void 0 ? void 0 : expiredAt.toJSON();

            _this3.events.emit('token-refreshed', {
              token: token,
              refreshToken: refreshToken,
              expiredAt: expiredAt
            });
          },
          getAuthenticationStatus: function getAuthenticationStatus() {
            return _this3.user_id != null && _this3.isLogin;
          }
        });
        _this3.userAdapter = new _user["default"](_this3.HTTPAdapter);
        _this3.roomAdapter = new _room["default"](_this3.HTTPAdapter);

        _this3.realtimeAdapter.subscribeUserChannel();

        if (_this3.presensePublisherId != null && _this3.presensePublisherId !== -1) {
          clearInterval(_this3.presensePublisherId);
        }

        _this3.presensePublisherId = setInterval(function () {
          _this3.realtimeAdapter.publishPresence(_this3.user_id, true);
        }, 3500); // if (this.sync === "http" || this.sync === "both") this.activateSync();

        if (_this3.options.loginSuccessCallback) {
          _this3.options.loginSuccessCallback(response);
        }

        _this3.authAdapter.userId = _this3.userData.email;
        _this3.authAdapter.refreshToken = _this3.userData.refresh_token;
        _this3.authAdapter.autoRefreshToken = _this3._autoRefreshToken;
      });
      /**
       * Called when there's something wrong when connecting to qiscus SDK
       */

      self.events.on('login-error', function (error) {
        if (self.options.loginErrorCallback) {
          self.options.loginErrorCallback(error);
        }
      });
      self.events.on('token-refreshed', function (param) {
        var _this3$options$authTo, _this3$options;

        (_this3$options$authTo = (_this3$options = _this3.options).authTokenRefreshedCallback) === null || _this3$options$authTo === void 0 ? void 0 : _this3$options$authTo.call(_this3$options, param);
      });
      self.events.on('room-cleared', function (room) {
        // find room
        if (self.selected) {
          var currentRoom = self.selected;

          if (self.selected.unique_id === room.unique_id) {
            self.selected = null;
            self.selected = currentRoom;
          }
        }

        if (self.options.roomClearedCallback) {
          self.options.roomClearedCallback(room);
        }
      });
      self.events.on('comment-deleted', function (data) {
        // get to the room id and delete the comment
        var roomId = data.roomId,
            commentUniqueIds = data.commentUniqueIds,
            isForEveryone = data.isForEveryone,
            isHard = data.isHard;

        if (self.selected && self.selected.id == roomId) {
          // loop through the array of unique_ids
          commentUniqueIds.map(function (id) {
            var commentToBeFound = self.selected.comments.findIndex(function (comment) {
              return comment.unique_id === id;
            });

            if (commentToBeFound > -1) {
              if (isHard) {
                self.selected.comments.splice(commentToBeFound, 1);
              } else {
                self.selected.comments[commentToBeFound].message = 'this message has been deleted';
              }
            }
          });
        }

        if (self.options.commentDeletedCallback) {
          self.options.commentDeletedCallback(data);
        }
      });
      /**
       * Called when the comment has been delivered
       */

      self.events.on('comment-delivered', function (response) {
        self.logging('comment-delivered', response);
        if (!response) return false;

        if (self.options.commentDeliveredCallback) {
          return self.options.commentDeliveredCallback(response);
        } // find comment with the id or unique id listed from response
        // const commentToFind = self.selected.comments.find(comment =>
        //   comment.id === response.id || comment.uniqueId === response.uniqueId);

      });
      /**
       * Called when new chatroom has been created
       */

      self.events.on('chat-room-created', function (response) {
        self.isLoading = false;

        if (self.options.chatRoomCreatedCallback) {
          self.options.chatRoomCreatedCallback(response);
        }
      });
      /**
       * Called when a new room with type of group has been created
       */

      self.events.on('group-room-created', function (response) {
        self.isLoading = false;

        if (self.options.groupRoomCreatedCallback) {
          self.options.groupRoomCreatedCallback(response);
        }
      });
      /**
       * Called when user clicked on Chat SDK Header
       */

      self.events.on('header-clicked', function (response) {
        if (self.options.headerClickedCallback) {
          self.options.headerClickedCallback(response);
        }
      });
      /**
       * Called when a comment has been read
       */

      self.events.on('comment-read', function (response) {
        self.logging('comment-read', response);

        if (self.options.commentReadCallback) {
          self.options.commentReadCallback(response);
        }
      });
      /**
       * Called when there's new presence data of currently subscribed target user (last seen timestamp)
       * @param {string} data MQTT Payload with format of "x:xxxxxxxxxxxxx"
       */

      self.events.on('presence', function (_ref5) {
        var message = _ref5.message,
            userId = _ref5.userId;
        var payload = message.split(':');

        if (_this3.chatmateStatus !== payload[0]) {
          _this3.chatmateStatus = payload[0] === 1 ? 'Online' : "Last seen ".concat((0, _distance_in_words_to_now["default"])(Number(payload[1].substring(0, 13))));
        }

        if (self.options.presenceCallback) self.options.presenceCallback(message, userId);
      });
      self.events.on('typing', function (data) {
        if (self.options.typingCallback) self.options.typingCallback(data);
      });
      /**
       * Called when user clicked on Message Info
       */

      self.events.on('message-info', function (response) {
        if (self.options.messageInfoCallback) {
          self.options.messageInfoCallback(response);
        }
      });
      /**
       * Called when new particant was added into a group
       */

      self.events.on('participants-added', function (response) {
        var _this3$selected$parti;

        if (response == null || _this3.selected == null) return;

        (_this3$selected$parti = _this3.selected.participants).push.apply(_this3$selected$parti, (0, _toConsumableArray2["default"])(response));
      });
      /**
       * Called when particant was removed from a group
       */

      self.events.on('participants-removed', function (response) {
        if (response == null || _this3.selected == null) return;

        var participants = _this3.selected.participants.filter(function (participant) {
          return response.indexOf(participant.email) <= -1;
        });

        _this3.selected.participants = participants;
      });
      /**
       * Called when user was added to blocked list
       */

      self.events.on('block-user', function (response) {
        if (self.options.blockUserCallback) {
          self.options.blockUserCallback(response);
        }
      });
      /**
       * Called when user was removed from blocked list
       */

      self.events.on('unblock-user', function (response) {
        if (self.options.unblockUserCallback) {
          self.options.unblockUserCallback(response);
        }
      });
    }
  }, {
    key: "onReconnectMqtt",
    value: function onReconnectMqtt() {
      if (this.options.onReconnectCallback) this.options.onReconnectedCallback();
      if (!this.selected) return;
      this.loadComments(this.selected.id);
    }
  }, {
    key: "_callNewMessagesCallback",
    value: function _callNewMessagesCallback(comments) {
      if (this.options.newMessagesCallback) {
        this.options.newMessagesCallback(comments);
      }
    }
  }, {
    key: "updateLastReceivedComment",
    value: function updateLastReceivedComment(id) {
      if (this.last_received_comment_id < id) {
        this.last_received_comment_id = id;
      }
    }
    /**
     * Setting Up User Credentials for next API Request
     * @param userId {string} - client userId (will be used for login or register)
     * @param key {string} - client unique key
     * @param username {string} - client username
     * @param avatarURL {string} - the url for chat avatar (optional)
     * @param extras {object} - extra data for user
     * @return {Promise}
     */

  }, {
    key: "setUser",
    value: function setUser(userId, key, username, avatarURL, extras) {
      var _this4 = this;

      var self = this;
      self.user_id = userId;
      self.key = key;
      self.username = username;
      self.avatar_url = avatarURL;
      var params = {
        email: this.user_id,
        password: this.key,
        username: this.username,
        extras: extras ? JSON.stringify(extras) : null
      };
      if (this.avatar_url) params.avatar_url = this.avatar_url;
      return new Promise(function (resolve, reject) {
        var waitingConfig = setInterval(function () {
          if (!_this4.isConfigLoaded) {
            if (_this4.debugMode) {
              _this4.logger('Waiting for init config...');
            }
          } else {
            clearInterval(waitingConfig);

            _this4.logger('Config Success!');

            self.events.emit('start-init');
            var login$ = self.authAdapter.loginOrRegister(params).then(function (response) {
              self.isInit = true;
              self.refresh_token = response.user.refresh_token;
              self.events.emit('login-success', response);

              _this4.realtimeAdapter.connect();

              resolve(response);
            }, function (error) {
              self.events.emit('login-error', error);
              reject(error);
            });
            return login$;
          }
        }, 300);
      });
    }
  }, {
    key: "setUserWithIdentityToken",
    value: function setUserWithIdentityToken(data) {
      var _this5 = this;

      if (!data || !('user' in data)) return this.events.emit('login-error', data);
      this.email = data.user.email;
      this.user_id = data.user.email;
      this.key = data.identity_token;
      this.username = data.user.username;
      this.avatar_url = data.user.avatar_url;
      this.isInit = true;
      var waitingConfig = setInterval(function () {
        if (!_this5.isConfigLoaded) {
          if (_this5.debugMode) {
            _this5.logger('Waiting for init config...');
          }
        } else {
          clearInterval(waitingConfig);

          _this5.logger('Config Success!');

          _this5.events.emit('login-success', data);
        }
      }, 300);
    }
  }, {
    key: "refreshAuthToken",
    value: function refreshAuthToken() {
      return this.expiredTokenAdapter.refreshAuthToken();
    }
  }, {
    key: "publishOnlinePresence",
    value: function publishOnlinePresence(val) {
      var _this6 = this;

      if (val === true) {
        setBackToOnline = setInterval(function () {
          _this6.realtimeAdapter.publishPresence(_this6.user_id, true);
        }, 3500);
      } else {
        clearInterval(this.presensePublisherId);
        clearInterval(setBackToOnline);
        setTimeout(function () {
          _this6.realtimeAdapter.publishPresence(_this6.user_id, false);
        }, 3500);
      }
    }
  }, {
    key: "subscribeUserPresence",
    value: function subscribeUserPresence(userId) {
      this.realtimeAdapter.subscribeUserPresence(userId);
    }
  }, {
    key: "unsubscribeUserPresence",
    value: function unsubscribeUserPresence(userId) {
      this.realtimeAdapter.unsubscribeUserPresence(userId);
    }
  }, {
    key: "logout",
    value: function () {
      var _logout = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return this.expiredTokenAdapter.logout();

              case 2:
                clearInterval(this.presensePublisherId);
                this.publishOnlinePresence(false);
                this.selected = null;
                this.isInit = false;
                this.isLogin = false;
                this.realtimeAdapter.disconnect();
                this.userData = {};

              case 9:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function logout() {
        return _logout.apply(this, arguments);
      }

      return logout;
    }()
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.logout();
    }
  }, {
    key: "setActiveRoom",
    value: function setActiveRoom(room) {
      var _this7 = this;

      // when we activate a room
      // we need to unsubscribe from typing event
      if (this.selected) {
        this.realtimeAdapter.unsubscribeTyping(); // before we unsubscribe, we need to get the userId first
        // and only unsubscribe if the previous room is having a type of 'single'

        if (this.selected.room_type === 'single') {
          var unsubscribedUserId = this.selected.participants.filter(function (p) {
            return p.email !== _this7.user_id;
          });

          if (unsubscribedUserId.length > 0) {
            this.realtimeAdapter.unsubscribeRoomPresence(unsubscribedUserId[0].email);
          }
        }
      }

      if (room.participants == null) room.participants = [];
      var targetUserId = room.participants.find(function (p) {
        return p.email !== _this7.user_id;
      });
      this.chatmateStatus = null;
      this.isTypingStatus = null;
      this.selected = room; // found a bug where there's a race condition, subscribing to mqtt
      // while mqtt is still connecting, so we'll have to do this hack

      var initialSubscribe = setInterval(function () {
        // Clear Interval when realtimeAdapter has been Populated
        if (_this7.debugMode) {
          _this7.logger('Trying Initial Subscribe');
        }

        if (_this7.realtimeAdapter != null) {
          if (_this7.debugMode) {
            _this7.logger('MQTT Connected');
          }

          clearInterval(initialSubscribe); // before we unsubscribe, we need to get the userId first
          // and only unsubscribe if the previous room is having a type of 'single'

          if (room.room_type === 'single' && targetUserId != null) {
            _this7.realtimeAdapter.subscribeRoomPresence(targetUserId.email);
          } // we need to subscribe to new room typing event now


          if (_this7.selected != null && !_this7.selected.isChannel) {
            _this7.realtimeAdapter.subscribeTyping(room.id);

            _this7.events.emit('room-changed', _this7.selected);
          }

          if (_this7.debugMode && _this7.realtimeAdapter == null) {
            _this7.logger('Retry');
          }
        } else {
          if (_this7.debugMode) {
            _this7.logger('MQTT Not Connected, yet');
          }
        }
      }, 3000);
    }
    /**
     * Chat with targetted email
     * @param userId {string} - target userId
     * @param options {object} - optional data sent to qiscus database
     * @return room <Room>
     */

  }, {
    key: "chatTarget",
    value: function chatTarget(userId) {
      var _this8 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      // make sure data already loaded first (user already logged in)
      if (this.userData.length != null) return false;
      var initialMessage = options ? options.message : null;
      var distinctId = options.distinctId;
      this.isLoading = true;
      this.isTypingStatus = ''; // Create room

      return this.roomAdapter.getOrCreateRoom(userId, options, distinctId).then( /*#__PURE__*/function () {
        var _ref6 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6(resp) {
          var room, mapIntercept, lastComment, topicId;
          return _regenerator["default"].wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  room = new _Room["default"](resp);

                  _this8.updateLastReceivedComment(room.last_comment_id);

                  _this8.isLoading = false;

                  mapIntercept = /*#__PURE__*/function () {
                    var _ref7 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5(it) {
                      return _regenerator["default"].wrap(function _callee5$(_context5) {
                        while (1) {
                          switch (_context5.prev = _context5.next) {
                            case 0:
                              _context5.next = 2;
                              return _this8._hookAdapter.trigger(_hook.Hooks.MESSAGE_BEFORE_RECEIVED, it);

                            case 2:
                              return _context5.abrupt("return", _context5.sent);

                            case 3:
                            case "end":
                              return _context5.stop();
                          }
                        }
                      }, _callee5);
                    }));

                    return function mapIntercept(_x5) {
                      return _ref7.apply(this, arguments);
                    };
                  }();

                  _context6.next = 6;
                  return Promise.all(room.comments.map(function (comment) {
                    return mapIntercept(comment);
                  }));

                case 6:
                  room.comments = _context6.sent;

                  _this8.setActiveRoom(room); // id of last comment on this room


                  lastComment = room.comments[room.comments.length - 1];
                  if (lastComment) _this8.readComment(room.id, lastComment.id);

                  _this8.events.emit('chat-room-created', {
                    room: room
                  });

                  if (initialMessage) {
                    _context6.next = 13;
                    break;
                  }

                  return _context6.abrupt("return", room);

                case 13:
                  topicId = room.id;
                  return _context6.abrupt("return", _this8.sendComment(topicId, initialMessage).then(function () {
                    return Promise.resolve(room);
                  })["catch"](function (err) {
                    console.error('Error when submit comment', err);
                  }));

                case 15:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6);
        }));

        return function (_x4) {
          return _ref6.apply(this, arguments);
        };
      }())["catch"](function (err) {
        console.error('Error when creating room', err);
        _this8.isLoading = false;
        return Promise.reject(err);
      });
    }
    /**
     *
     * Open a group chat or target a specific room id
     *
     * @param {int} id
     * @returns Room <Room>
     * @memberof QiscusSDK
     */

  }, {
    key: "chatGroup",
    value: function chatGroup(id) {
      var self = this;
      if (!self.isInit) return;
      return self.getRoomById(id).then(function (response) {
        return Promise.resolve(response);
      }, function (err) {
        return Promise.reject(err);
      });
    }
    /**
     * @param {int} id - Room Id
     * @return {Room} Room data
     */

  }, {
    key: "getRoomById",
    value: function getRoomById(id) {
      var _this9 = this;

      if (!this.isInit) return;
      var self = this;
      self.isLoading = true;
      self.isTypingStatus = '';
      return self.roomAdapter.getRoomById(id).then( /*#__PURE__*/function () {
        var _ref8 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(resp) {
          var roomData, comments, _iterator, _step, comment, c, room, lastComment;

          return _regenerator["default"].wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  roomData = resp.results.room;
                  comments = [];
                  _iterator = _createForOfIteratorHelper(resp.results.comments.reverse());
                  _context7.prev = 3;

                  _iterator.s();

                case 5:
                  if ((_step = _iterator.n()).done) {
                    _context7.next = 13;
                    break;
                  }

                  comment = _step.value;
                  _context7.next = 9;
                  return _this9._hookAdapter.trigger(_hook.Hooks.MESSAGE_BEFORE_RECEIVED, comment);

                case 9:
                  c = _context7.sent;
                  comments.push(c);

                case 11:
                  _context7.next = 5;
                  break;

                case 13:
                  _context7.next = 18;
                  break;

                case 15:
                  _context7.prev = 15;
                  _context7.t0 = _context7["catch"](3);

                  _iterator.e(_context7.t0);

                case 18:
                  _context7.prev = 18;

                  _iterator.f();

                  return _context7.finish(18);

                case 21:
                  // .map((it) =>
                  //   this._hookAdapter.trigger(Hooks.MESSAGE_BEFORE_RECEIVED, it)
                  // );
                  room = new _Room["default"](_objectSpread(_objectSpread({}, roomData), {}, {
                    comments: comments,
                    name: roomData.room_name
                  }));
                  self.updateLastReceivedComment(room.last_comment_id);
                  self.setActiveRoom(room);
                  self.isLoading = false; // id of last comment on this room

                  lastComment = room.comments[room.comments.length - 1];
                  if (lastComment) self.readComment(room.id, lastComment.id);

                  if (room.isChannel) {
                    _this9.realtimeAdapter.subscribeChannel(_this9.AppId, room.unique_id);
                  }

                  return _context7.abrupt("return", room);

                case 29:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, null, [[3, 15, 18, 21]]);
        }));

        return function (_x6) {
          return _ref8.apply(this, arguments);
        };
      }())["catch"](function (error) {
        console.error('Error getting room by id', error);
        return Promise.reject(error);
      });
    }
    /**
     * @param {int} id - Room Id
     * @param {string} roomName
     * @param {string} avatarURL
     * @return {Room} Room data
     */

  }, {
    key: "getOrCreateRoomByUniqueId",
    value: function getOrCreateRoomByUniqueId(id, roomName, avatarURL) {
      var _this10 = this;

      var self = this;
      self.isLoading = true;
      self.isTypingStatus = '';
      return self.roomAdapter.getOrCreateRoomByUniqueId(id, roomName, avatarURL).then( /*#__PURE__*/function () {
        var _ref9 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9(response) {
          var room, mapIntercept, lastComment;
          return _regenerator["default"].wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  // make sure the room hasn't been pushed yet
                  room = new _Room["default"](response);
                  self.updateLastReceivedComment(room.last_comment_id);

                  mapIntercept = /*#__PURE__*/function () {
                    var _ref10 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(item) {
                      return _regenerator["default"].wrap(function _callee8$(_context8) {
                        while (1) {
                          switch (_context8.prev = _context8.next) {
                            case 0:
                              _context8.next = 2;
                              return _this10._hookAdapter.trigger(_hook.Hooks.MESSAGE_BEFORE_RECEIVED, item);

                            case 2:
                              return _context8.abrupt("return", _context8.sent);

                            case 3:
                            case "end":
                              return _context8.stop();
                          }
                        }
                      }, _callee8);
                    }));

                    return function mapIntercept(_x8) {
                      return _ref10.apply(this, arguments);
                    };
                  }();

                  _context9.next = 5;
                  return Promise.all(room.comments.map(function (it) {
                    return mapIntercept(it);
                  }));

                case 5:
                  room.comments = _context9.sent;
                  self.setActiveRoom(room);
                  self.isLoading = false;
                  lastComment = room.comments[room.comments.length - 1];
                  if (lastComment) self.readComment(room.id, lastComment.id);

                  _this10.realtimeAdapter.subscribeChannel(_this10.AppId, room.unique_id);

                  return _context9.abrupt("return", Promise.resolve(room));

                case 12:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9);
        }));

        return function (_x7) {
          return _ref9.apply(this, arguments);
        };
      }())["catch"](function (error) {
        // console.error('Error getting room by id', error)
        return Promise.reject(error);
      });
    }
  }, {
    key: "getOrCreateRoomByChannel",
    value: function getOrCreateRoomByChannel(channel, name, avatarURL) {
      return this.getOrCreateRoomByUniqueId(channel, name, avatarURL);
    }
  }, {
    key: "sortComments",
    value: function sortComments() {
      this.selected && this.selected.comments.sort(function (leftSideComment, rightSideComment) {
        return leftSideComment.unix_timestamp - rightSideComment.unix_timestamp;
      });
    }
  }, {
    key: "loadRoomList",
    value: function () {
      var _loadRoomList = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10() {
        var params,
            rooms,
            _args10 = arguments;
        return _regenerator["default"].wrap(function _callee10$(_context10) {
          while (1) {
            switch (_context10.prev = _context10.next) {
              case 0:
                params = _args10.length > 0 && _args10[0] !== undefined ? _args10[0] : {};
                _context10.next = 3;
                return this.userAdapter.loadRoomList(params);

              case 3:
                rooms = _context10.sent;
                return _context10.abrupt("return", rooms.map(function (room) {
                  room.last_comment_id = room.last_comment.id;
                  room.last_comment_message = room.last_comment.message;
                  room.last_comment_message_created_at = room.last_comment.timestamp;
                  room.room_type = room.chat_type;
                  room.comments = [];
                  return new _Room["default"](room);
                }));

              case 5:
              case "end":
                return _context10.stop();
            }
          }
        }, _callee10, this);
      }));

      function loadRoomList() {
        return _loadRoomList.apply(this, arguments);
      }

      return loadRoomList;
    }()
  }, {
    key: "loadComments",
    value: function loadComments(roomId) {
      var _this11 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.userAdapter.loadComments(roomId, options).then( /*#__PURE__*/function () {
        var _ref11 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11(comments_) {
          var comments, _iterator2, _step2, comment;

          return _regenerator["default"].wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  comments = [];
                  _iterator2 = _createForOfIteratorHelper(comments_);
                  _context11.prev = 2;

                  _iterator2.s();

                case 4:
                  if ((_step2 = _iterator2.n()).done) {
                    _context11.next = 13;
                    break;
                  }

                  comment = _step2.value;
                  _context11.t0 = comments;
                  _context11.next = 9;
                  return _this11._hookAdapter.trigger(_hook.Hooks.MESSAGE_BEFORE_RECEIVED, comment);

                case 9:
                  _context11.t1 = _context11.sent;

                  _context11.t0.push.call(_context11.t0, _context11.t1);

                case 11:
                  _context11.next = 4;
                  break;

                case 13:
                  _context11.next = 18;
                  break;

                case 15:
                  _context11.prev = 15;
                  _context11.t2 = _context11["catch"](2);

                  _iterator2.e(_context11.t2);

                case 18:
                  _context11.prev = 18;

                  _iterator2.f();

                  return _context11.finish(18);

                case 21:
                  if (_this11.selected != null) {
                    _this11.selected.receiveComments(comments.reverse());

                    _this11.sortComments();
                  }

                  return _context11.abrupt("return", comments);

                case 23:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11, null, [[2, 15, 18, 21]]);
        }));

        return function (_x9) {
          return _ref11.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "loadMore",
    value: function loadMore(lastCommentId) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (this.selected == null) return;
      options.last_comment_id = lastCommentId;
      options.after = false;
      return this.loadComments(this.selected.id, options);
    }
  }, {
    key: "registerDeviceToken",
    value: function () {
      var _registerDeviceToken = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12(token) {
        var isDevelopment,
            res,
            _args12 = arguments;
        return _regenerator["default"].wrap(function _callee12$(_context12) {
          while (1) {
            switch (_context12.prev = _context12.next) {
              case 0:
                isDevelopment = _args12.length > 1 && _args12[1] !== undefined ? _args12[1] : false;
                _context12.next = 3;
                return this.HTTPAdapter.post('api/v2/sdk/set_user_device_token', {
                  device_token: token,
                  device_platform: 'rn',
                  is_development: isDevelopment
                });

              case 3:
                res = _context12.sent;
                return _context12.abrupt("return", res.body.results);

              case 5:
              case "end":
                return _context12.stop();
            }
          }
        }, _callee12, this);
      }));

      function registerDeviceToken(_x10) {
        return _registerDeviceToken.apply(this, arguments);
      }

      return registerDeviceToken;
    }()
  }, {
    key: "removeDeviceToken",
    value: function () {
      var _removeDeviceToken = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13(token) {
        var isDevelopment,
            res,
            _args13 = arguments;
        return _regenerator["default"].wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                isDevelopment = _args13.length > 1 && _args13[1] !== undefined ? _args13[1] : false;
                _context13.next = 3;
                return this.HTTPAdapter.post('api/v2/sdk/remove_user_device_token', {
                  device_token: token,
                  device_platform: 'rn',
                  is_development: isDevelopment
                });

              case 3:
                res = _context13.sent;
                return _context13.abrupt("return", res.body.results);

              case 5:
              case "end":
                return _context13.stop();
            }
          }
        }, _callee13, this);
      }));

      function removeDeviceToken(_x11) {
        return _removeDeviceToken.apply(this, arguments);
      }

      return removeDeviceToken;
    }()
    /**
     *
     * Search Qiscus Messages
     *
     * @param {any} [params={query,room_id,last_comment_id}]
     * @memberof qiscusSDK
     */

  }, {
    key: "searchMessages",
    value: function () {
      var _searchMessages = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee14() {
        var params,
            messages,
            _args14 = arguments;
        return _regenerator["default"].wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                params = _args14.length > 0 && _args14[0] !== undefined ? _args14[0] : {};
                console.warn('Deprecated: search message will be removed on next release');
                _context14.next = 4;
                return this.userAdapter.searchMessages(params);

              case 4:
                messages = _context14.sent;
                return _context14.abrupt("return", messages.map(function (message) {
                  return new _Comment["default"](message);
                }));

              case 6:
              case "end":
                return _context14.stop();
            }
          }
        }, _callee14, this);
      }));

      function searchMessages() {
        return _searchMessages.apply(this, arguments);
      }

      return searchMessages;
    }()
  }, {
    key: "updateProfile",
    value: function updateProfile(user) {
      var _this12 = this;

      return this.userAdapter.updateProfile(user).then(function (res) {
        _this12.events.emit('profile-updated', user);

        _this12.userData = res;
        return Promise.resolve(res);
      }, function (err) {
        return _this12.logger(err);
      });
    }
  }, {
    key: "getNonce",
    value: function getNonce() {
      return _superagent["default"].post("".concat(this.baseURL, "/api/v2/sdk/auth/nonce")).send().set('qiscus_sdk_app_id', "".concat(this.AppId)).set('qiscus_sdk_version', "".concat(this.version)).then(function (res) {
        return Promise.resolve(res.body.results);
      }, function (err) {
        return Promise.reject(err);
      });
    }
  }, {
    key: "verifyIdentityToken",
    value: function verifyIdentityToken(identityToken) {
      return _superagent["default"].post("".concat(this.baseURL, "/api/v2/sdk/auth/verify_identity_token")).send({
        identity_token: identityToken
      }).set('qiscus_sdk_app_id', "".concat(this.AppId)).set('qiscus_sdk_version', "".concat(this.version)).then(function (res) {
        return Promise.resolve(res.body.results);
      }, function (err) {
        return Promise.reject(err);
      });
    }
    /**
     *
     * Step of submitting:
     * - we need to create a new comment object
     * - attach it with negative number id, and also the uniqueId, uniqueId is used
     *   to target this particular comment when there's response from server (sent, delivered state)
     * @param {Int} topicId - the topic id of comment to be submitted
     * @param {String} commentMessage - comment to be submitted
     * @param uniqueId {String}
     * @param type     {String}
     * @param payload  {Object}
     * @param extras   {Object}
     * @return {Promise}
     */
    // #region sendComment

  }, {
    key: "sendComment",
    value: function () {
      var _sendComment = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee16(topicId, commentMessage, uniqueId) {
        var _this13 = this;

        var type,
            payload,
            extras,
            self,
            commentData,
            pendingComment,
            parsedPayload,
            repliedMessage,
            extrasToBeSubmitted,
            messageData,
            _args16 = arguments;
        return _regenerator["default"].wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                type = _args16.length > 3 && _args16[3] !== undefined ? _args16[3] : 'text';
                payload = _args16.length > 4 ? _args16[4] : undefined;
                extras = _args16.length > 5 ? _args16[5] : undefined;
                self = this; // set extra data, etc

                if (self.options.prePostCommentCallback) {
                  self.options.prePostCommentCallback(commentMessage);
                }
                /**
                 * example:
                 * commentFormaterCallback(msg) {
                 *  return filterBadWords(msg) // define your own filter function and return its' value
                 * }
                 */


                if (self.options.commentFormaterCallback) {
                  commentMessage = self.options.commentFormaterCallback(commentMessage);
                }

                self.pendingCommentId--;
                commentData = {
                  message: commentMessage,
                  username_as: this.username,
                  username_real: this.user_id,
                  user_avatar_url: this.userData.avatar_url,
                  user_extras: this.userData.user_extras,
                  id: Math.round(Date.now() * 1e6 + Date.now()),
                  type: type || 'text',
                  timestamp: (0, _format["default"])(new Date()),
                  unique_id: uniqueId ? String(uniqueId) : null,
                  payload: (0, _util.tryCatch)(function () {
                    return JSON.parse(payload);
                  }, payload, function (error) {
                    return _this13.logger('Error when parsing payload', error.message);
                  })
                };
                pendingComment = self.prepareCommentToBeSubmitted(commentData); // push this comment unto active room

                if (type === 'reply') {
                  // change payload for pendingComment
                  // get the comment for current replied id
                  parsedPayload = JSON.parse(payload);
                  repliedMessage = self.selected.comments.find(function (cmt) {
                    return cmt.id === parsedPayload.replied_comment_id;
                  });
                  parsedPayload.replied_comment_message = repliedMessage.type === 'reply' ? repliedMessage.payload.text : repliedMessage.message;
                  parsedPayload.replied_comment_sender_username = repliedMessage.username_as;
                  pendingComment.payload = parsedPayload;
                }

                extrasToBeSubmitted = extras || self.extras;
                _context16.next = 13;
                return this._hookAdapter.trigger(_hook.Hooks.MESSAGE_BEFORE_SENT, _objectSpread(_objectSpread({}, pendingComment), {}, {
                  extras: extrasToBeSubmitted
                }));

              case 13:
                messageData = _context16.sent;
                messageData = self.prepareCommentToBeSubmitted(messageData);
                if (self.selected) self.selected.comments.push(messageData);
                return _context16.abrupt("return", this.userAdapter.postComment('' + topicId, messageData.message, messageData.unique_id, messageData.type, messageData.payload, messageData.extras).then( /*#__PURE__*/function () {
                  var _ref12 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee15(res) {
                    return _regenerator["default"].wrap(function _callee15$(_context15) {
                      while (1) {
                        switch (_context15.prev = _context15.next) {
                          case 0:
                            _context15.next = 2;
                            return _this13._hookAdapter.trigger(_hook.Hooks.MESSAGE_BEFORE_RECEIVED, res);

                          case 2:
                            res = _context15.sent;
                            Object.assign(messageData, res);

                            if (self.selected) {
                              _context15.next = 6;
                              break;
                            }

                            return _context15.abrupt("return", Promise.resolve(messageData));

                          case 6:
                            // When the posting succeeded, we mark the Comment as sent,
                            // so all the interested party can be notified.
                            messageData.markAsSent();
                            messageData.id = res.id;
                            messageData.before_id = res.comment_before_id; // update the timestamp also then re-sort the comment list

                            messageData.unix_timestamp = res.unix_timestamp;
                            self.sortComments();
                            return _context15.abrupt("return", messageData);

                          case 12:
                          case "end":
                            return _context15.stop();
                        }
                      }
                    }, _callee15);
                  }));

                  return function (_x15) {
                    return _ref12.apply(this, arguments);
                  };
                }())["catch"](function (err) {
                  messageData.markAsFailed();
                  return Promise.reject(err);
                }));

              case 17:
              case "end":
                return _context16.stop();
            }
          }
        }, _callee16, this);
      }));

      function sendComment(_x12, _x13, _x14) {
        return _sendComment.apply(this, arguments);
      }

      return sendComment;
    }() // #endregion

  }, {
    key: "getUsers",
    value: function getUsers() {
      var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var page = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 20;
      return this.HTTPAdapter.get_request('api/v2/sdk/get_user_list').query({
        query: query,
        page: page,
        limit: limit
      }).then(function (resp) {
        return Promise.resolve(resp.body.results);
      });
    }
  }, {
    key: "getParticipants",
    value: function getParticipants(roomUniqueId) {
      var page = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 20;
      return this.HTTPAdapter.get_request('api/v2/sdk/room_participants').query({
        room_unique_id: roomUniqueId,
        page: page,
        limit: limit
      }).then(function (resp) {
        return resp.body.results;
      });
    }
  }, {
    key: "getRoomParticipants",
    value: function getRoomParticipants(roomUniqueId) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      console.warn('`getRoomParticipants` are deprecated, use `getParticipants` instead.');
      return this.HTTPAdapter.get_request('api/v2/sdk/room_participants').query({
        room_unique_id: roomUniqueId,
        offset: offset
      }).then(function (resp) {
        return Promise.resolve(resp.body.results);
      });
    }
  }, {
    key: "resendComment",
    value: function resendComment(comment) {
      if (this.selected == null) return;
      var self = this;
      var room = self.selected;
      var pendingComment = room.comments.find(function (cmtToFind) {
        return cmtToFind.id === comment.id;
      });
      var extrasToBeSubmitted = self.extras;
      return this.userAdapter.postComment('' + room.id, pendingComment.message, pendingComment.unique_id, comment.type, comment.payload, extrasToBeSubmitted).then(function (res) {
        // When the posting succeeded, we mark the Comment as sent,
        // so all the interested party can be notified.
        pendingComment.markAsSent();
        pendingComment.id = res.id;
        pendingComment.before_id = res.comment_before_id;
        return new Promise(function (resolve, reject) {
          return resolve(self.selected);
        });
      }, function (err) {
        pendingComment.markAsFailed();
        return new Promise(function (resolve, reject) {
          return reject(err);
        });
      });
    }
  }, {
    key: "prepareCommentToBeSubmitted",
    value: function prepareCommentToBeSubmitted(comment) {
      var commentToBeSubmitted, uniqueId;
      commentToBeSubmitted = new _Comment["default"](comment); // We're gonna use timestamp for uniqueId for now.
      // "bq" stands for "Bonjour Qiscus" by the way.

      uniqueId = 'bq' + Date.now();
      if (comment.unique_id) uniqueId = comment.unique_id;
      commentToBeSubmitted.attachUniqueId(uniqueId);
      commentToBeSubmitted.markAsPending();
      commentToBeSubmitted.isDelivered = false;
      commentToBeSubmitted.isSent = false;
      commentToBeSubmitted.isRead = false;
      commentToBeSubmitted.unix_timestamp = Math.round(new Date().getTime() / 1000);
      return commentToBeSubmitted;
    }
    /**
     * Update room
     * @param {id, room_name, avatar_url, options} args
     * @return Promise
     */

  }, {
    key: "updateRoom",
    value: function updateRoom(args) {
      return this.roomAdapter.updateRoom(args);
    }
  }, {
    key: "removeSelectedRoomParticipants",
    value: function removeSelectedRoomParticipants() {
      var values = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var payload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'id';

      if (_is_js["default"].not.array(values)) {
        return Promise.reject(new Error('`values` must have type of array'));
      }

      var participants = this.selected.participants;

      if (!participants) {
        return Promise.reject(new Error('Nothing selected room chat.'));
      } // start to changes selected participants with newest values


      var participantsExclude = participants;

      if (payload === 'id') {
        participantsExclude = participants.filter(function (participant) {
          return values.indexOf(participant.id) <= -1;
        });
      }

      if (payload === 'email') {
        participantsExclude = participants.filter(function (participant) {
          return values.indexOf(participant.email) <= -1;
        });
      }

      if (payload === 'username') {
        participantsExclude = participants.filter(function (participant) {
          return values.indexOf(participant.username) <= -1;
        });
      }

      this.selected.participants = participantsExclude;
      return Promise.resolve(participants);
    }
    /**
     * Create group chat room
     * @param {string} name - Chat room name
     * @param {string[]} emails - Participant to be invited
     * @returns {Promise.<Room, Error>} - Room detail
     */

  }, {
    key: "createGroupRoom",
    value: function createGroupRoom(name, emails, options) {
      var self = this;
      if (!this.isLogin) throw new Error('Please initiate qiscus SDK first');
      return new _utils.GroupChatBuilder(this.roomAdapter).withName(name).withOptions(options).addParticipants(emails).create().then(function (res) {
        self.events.emit('group-room-created', res);
        return Promise.resolve(res);
      });
    }
    /**
     * Add array of participant into a group
     *
     * @param {any} roomId the room id this file is required for selected room_id to be process
     * @param {any} emails emails is must be an array
     * @returns Promise
     * @memberof QiscusSDK
     */

  }, {
    key: "addParticipantsToGroup",
    value: function addParticipantsToGroup(roomId, emails) {
      var self = this;

      if (!Array.isArray(emails)) {
        throw new Error("emails' must be type of Array");
      }

      return self.roomAdapter.addParticipantsToGroup(roomId, emails).then(function (res) {
        self.events.emit('participants-added', res);
        return Promise.resolve(res);
      }, function (err) {
        return Promise.reject(err);
      });
    }
    /**
     * Remove array of participant from a group
     *
     * @param {any} roomId the room id this file is required for selected room_id to be process
     * @param {any} emails emails is must be an array
     * @returns Promise
     * @memberof QiscusSDK
     */

  }, {
    key: "removeParticipantsFromGroup",
    value: function removeParticipantsFromGroup(roomId, emails) {
      var _this14 = this;

      if (_is_js["default"].not.array(emails)) {
        return Promise.reject(new Error('`emails` must have type of array'));
      }

      return this.roomAdapter.removeParticipantsFromGroup(roomId, emails).then(function (res) {
        _this14.events.emit('participants-removed', emails);

        return Promise.resolve(res);
      });
    }
    /**
     * Get user block list
     *
     * @param {any} page the page is optional, default=1
     * @param {any} limit the limit is optional, default=20
     * @returns Promise
     * @memberof QiscusSDK
     */

  }, {
    key: "getBlockedUser",
    value: function getBlockedUser() {
      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;
      var self = this;
      return self.userAdapter.getBlockedUser(page, limit).then(function (res) {
        return Promise.resolve(res);
      }, function (err) {
        return Promise.reject(err);
      });
    }
    /**
     * Add user to block list
     *
     * @param {any} email the email is required
     * @returns Promise
     * @memberof QiscusSDK
     */

  }, {
    key: "blockUser",
    value: function blockUser(email) {
      var self = this;
      return self.userAdapter.blockUser(email).then(function (res) {
        self.events.emit('block-user', res);
        return Promise.resolve(res);
      }, function (err) {
        return Promise.reject(err);
      });
    }
    /**
     * Remove user from block list
     *
     * @param {any} email the email is required
     * @returns Promise
     * @memberof QiscusSDK
     */

  }, {
    key: "unblockUser",
    value: function unblockUser(email) {
      var self = this;
      return self.userAdapter.unblockUser(email).then(function (res) {
        self.events.emit('unblock-user', res);
        return Promise.resolve(res);
      }, function (err) {
        return Promise.reject(err);
      });
    }
  }, {
    key: "getUserPresences",
    value: function getUserPresences() {
      var email = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      if (_is_js["default"].not.array(email)) {
        return Promise.reject(new Error('`email` must have type of array'));
      }

      var self = this;
      return self.userAdapter.getUserPresences(email).then(function (res) {
        self.events.emit('user-status', res);
        return Promise.resolve(res);
      }, function (err) {
        return Promise.reject(err);
      });
    }
  }, {
    key: "upload",
    value: function upload(file, callback) {
      var req = _superagent["default"].post(this.uploadURL);

      req = this.HTTPAdapter.setupHeaders(req);
      return req.attach('file', file).on('progress', function (event) {
        if (event.direction === 'upload') callback(null, event);
      }).then(function (resp) {
        var url = resp.body.results.file.url;
        callback(null, null, resp.body.results.file.url);
        return Promise.resolve(url);
      })["catch"](function (error) {
        callback(error);
        return Promise.reject(error);
      });
    }
    /**
     * Upload a file to qiscus sdk server
     *
     * @param {any} roomId the room id this file need to be submitted to
     * @param {any} file you can get this from event `e.target.files || e.dataTransfer.files`
     * @returns Promise
     * @memberof QiscusSDK
     */

  }, {
    key: "uploadFile",
    value: function uploadFile(roomId, file) {
      var self = this;
      var formData = new FormData();
      formData.append('file', file);
      var xhr = new XMLHttpRequest();
      xhr.open('POST', "".concat(self.baseURL, "/api/v2/sdk/upload"), true);
      xhr.setRequestHeader('qiscus_sdk_app_id', "".concat(self.AppId));
      xhr.setRequestHeader('qiscus_sdk_user_id', "".concat(self.user_id));
      xhr.setRequestHeader('qiscus_sdk_token', "".concat(self.userData.token));

      xhr.onload = function () {
        if (xhr.status === 200) {
          // file(s) uploaded), let's post to comment
          var url = JSON.parse(xhr.response).results.file.url;
          self.events.emit('fileupload', url); // send

          return self.sendComment(roomId, "[file] ".concat(url, " [/file]"));
        } else {
          return Promise.reject(xhr);
        }
      };

      xhr.send(formData);
    }
  }, {
    key: "addUploadedFile",
    value: function addUploadedFile(name, roomId) {
      this.uploadedFiles.push(new FileUploaded(name, roomId));
    }
  }, {
    key: "removeUploadedFile",
    value: function removeUploadedFile(name, roomId) {
      var index = this.uploadedFiles.findIndex(function (file) {
        return file.name === name && file.roomId === roomId;
      });
      this.uploadedFiles.splice(index, 1);
    }
  }, {
    key: "publishTyping",
    value: function publishTyping(val) {
      this.realtimeAdapter.publishTyping(val);
    }
    /**
     * Params consisted of
     * @param {room_ids} array of room ids
     * @param {room_unique_ids} array of of room unique ids
     * @param {show_participants} show list of participants, default true
     * @param {show_removed} show removed room, default false
     * @returns
     * @memberof QiscusSDK
     */

  }, {
    key: "getRoomsInfo",
    value: function getRoomsInfo(params) {
      return this.userAdapter.getRoomsInfo(params);
    }
  }, {
    key: "deleteComment",
    value: function deleteComment(roomId, commentUniqueIds, isForEveryone, isHard) {
      var _this15 = this;

      if (!Array.isArray(commentUniqueIds)) {
        throw new Error("unique ids' must be type of Array");
      }

      return this.userAdapter.deleteComment(roomId, commentUniqueIds, isForEveryone, isHard).then(function (res) {
        _this15.events.emit('comment-deleted', {
          roomId: roomId,
          commentUniqueIds: commentUniqueIds,
          isForEveryone: isForEveryone,
          isHard: isHard
        });

        return Promise.resolve(res);
      }, function (err) {
        return Promise.reject(err);
      });
    }
  }, {
    key: "clearRoomsCache",
    value: function clearRoomsCache() {
      var _this16 = this;

      // remove all room except currently selected
      if (this.selected) {
        // clear the map
        this.room_name_id_map = (0, _defineProperty2["default"])({}, this.selected.name, this.selected.id); // get current index and array length

        var roomLength = this.rooms.length;
        var curIndex = this.rooms.findIndex(function (room) {
          return room.id === _this16.selected.id;
        });

        if (!(curIndex + 1 === roomLength)) {
          this.rooms.splice(curIndex + 1, roomLength - (curIndex + 1));
        } // ambil ulang cur index nya, klo udah di awal ga perlu lagi kode dibawah ini


        curIndex = this.rooms.findIndex(function (room) {
          return room.id === _this16.selected.id;
        });

        if (curIndex > 0 && this.rooms.length > 1) {
          this.rooms.splice(1, this.rooms.length - 1);
        }
      }
    }
  }, {
    key: "exitChatRoom",
    value: function exitChatRoom() {
      var _this17 = this;

      // remove all subscriber
      this.realtimeAdapter.unsubscribeTyping();
      (0, _util.tryCatch)(function () {
        return _this17.selected.participants.filter(function (it) {
          return it.email !== _this17.user_id;
        }).map(function (it) {
          return it.email;
        });
      }, null, this.noop, function (userIds) {
        return userIds.forEach(function (userId) {
          return _this17.realtimeAdapter.unsubscribeRoomPresence(userId);
        });
      });
      this.selected = null;
    }
  }, {
    key: "clearRoomMessages",
    value: function clearRoomMessages(roomIds) {
      if (!Array.isArray(roomIds)) {
        throw new Error('room_ids must be type of array');
      }

      return this.userAdapter.clearRoomMessages(roomIds);
    }
  }, {
    key: "logging",
    value: function logging(message) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.debugMode) {
        console.log(message, params);
      }
    }
  }, {
    key: "getTotalUnreadCount",
    value: function getTotalUnreadCount() {
      return this.roomAdapter.getTotalUnreadCount().then(function (response) {
        return Promise.resolve(response);
      }, function (error) {
        return Promise.reject(error);
      });
    }
  }, {
    key: "getRoomUnreadCount",
    value: function getRoomUnreadCount() {
      return this.roomAdapter.getRoomUnreadCount();
    }
  }, {
    key: "publishEvent",
    value: function publishEvent() {
      var _this$customEventAdap;

      (_this$customEventAdap = this.customEventAdapter).publishEvent.apply(_this$customEventAdap, arguments);
    }
  }, {
    key: "subscribeEvent",
    value: function subscribeEvent() {
      var _this$customEventAdap2;

      (_this$customEventAdap2 = this.customEventAdapter).subscribeEvent.apply(_this$customEventAdap2, arguments);
    }
  }, {
    key: "unsubscribeEvent",
    value: function unsubscribeEvent() {
      var _this$customEventAdap3;

      (_this$customEventAdap3 = this.customEventAdapter).unsubscribeEvent.apply(_this$customEventAdap3, arguments);
    }
  }, {
    key: "setCustomHeader",
    value: function setCustomHeader(headers) {
      if (_is_js["default"].not.json(headers)) {
        throw new TypeError('`headers` must have type of object');
      }

      this._customHeader = headers;
    }
  }, {
    key: "getUserProfile",
    value: function getUserProfile() {
      return this.userAdapter.getProfile();
    }
  }, {
    key: "intercept",
    value: function intercept(interceptor, callback) {
      return this._hookAdapter.intercept(interceptor, callback);
    }
  }, {
    key: "getThumbnailURL",
    value: function getThumbnailURL(fileURL) {
      var reURL = /^https?:\/\/\S+(\/upload\/)\S+(\.\w+)$/i;
      return fileURL.replace(reURL, function (match, g1, g2) {
        return match.replace(g1, '/upload/w_320,h_320,c_limit/').replace(g2, '.png');
      });
    }
  }, {
    key: "getBlurryThumbnailURL",
    value: function getBlurryThumbnailURL(fileURL) {
      var reURL = /^https?:\/\/\S+(\/upload\/)\S+(\.\w+)$/i;
      return fileURL.replace(reURL, function (match, g1, g2) {
        return match.replace(g1, '/upload/w_320,h_320,c_limit,e_blur:300/').replace(g2, '.png');
      });
    }
  }, {
    key: "noop",
    value: function noop() {}
  }, {
    key: "_updateStatus",
    value: function _updateStatus(roomId) {
      var commentId1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var commentId2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      // The rules:
      // if it is receive command
      // - it is prohibited to send command if current room are channel
      // - it is ok to send command even if no room selected
      // - it is prohibited to send command when `updateCommentStatusMode` is `disabled`
      // if it is read command
      // - it is prohibited to send command if current room are channel
      // - it is prohibited to send command if no room selected (but why was this a thing?)
      // - it is ok to send command when `updateCommentStatusMode` is `disabled`
      var isReceiveCommand = commentId2 != null;
      var isReadCommand = commentId1 != null;
      var isSelected = this.selected != null && this.selected.id === roomId || false;
      var isChannel = this.selected != null && this.selected.isChannel || false;
      var isUpdateStatusDisabled = !this._updateStatusEnabled;

      var command = function () {
        if (isReadCommand) return 'read';
        if (isReceiveCommand) return 'receive';
      }();

      var isAbleToRunCommand = function () {
        if (isChannel) return false;
        if (isReceiveCommand && isUpdateStatusDisabled) return false;
        return true;
      }();

      if (this.debugMode) {
        console.group('update-command-status');
        console.log('run:', command, "on: roomId(".concat(roomId, ") commentId(").concat(commentId1 || commentId2, ")"));
        console.log('is able to run command?', isAbleToRunCommand);
        console.groupEnd();
      }

      if (!isAbleToRunCommand) return false;
      this.userAdapter.updateCommentStatus(roomId, commentId1, commentId2)["catch"](function (err) {});
    }
  }, {
    key: "readComment",
    value: function readComment(roomId, commentId) {
      if (this.updateCommentStatusMode === QiscusSDK.UpdateCommentStatusMode.enabled) return this._readComment(roomId, commentId);
      return this._readCommentT(roomId, commentId);
    }
  }, {
    key: "receiveComment",
    value: function receiveComment(roomId, commentId) {
      if (this.updateCommentStatusMode === QiscusSDK.UpdateCommentStatusMode.enabled) return this._deliverComment(roomId, commentId);
      return this._deliverCommentT(roomId, commentId);
    }
  }, {
    key: "_throttle",
    value: function _throttle(func, getWait) {
      var isWaiting = false;
      return function () {
        var waitTime = getWait();

        if (!isWaiting) {
          func.apply(void 0, arguments);
          isWaiting = true;
          setTimeout(function () {
            return isWaiting = false;
          }, waitTime);
        }
      };
    }
    /**
     * @typedef {Object} SearchMessageParams
     * @property {string} query
     * @property {Array.<number>} roomIds
     * @property {string} userId
     * @property {Array.<string>} type
     * @property {string} roomType
     * @property {number} page
     * @property {number} limit
     */

    /**
     *
     * @param {SearchMessageParams} param0
     * @returns {Array.<Object>}
     */

  }, {
    key: "searchMessage",
    value: function () {
      var _searchMessage = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee17() {
        var _ref13,
            query,
            _ref13$roomIds,
            roomIds,
            userId,
            type,
            roomType,
            page,
            limit,
            url,
            isValidRoomType,
            room,
            _args17 = arguments;

        return _regenerator["default"].wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _ref13 = _args17.length > 0 && _args17[0] !== undefined ? _args17[0] : {}, query = _ref13.query, _ref13$roomIds = _ref13.roomIds, roomIds = _ref13$roomIds === void 0 ? [] : _ref13$roomIds, userId = _ref13.userId, type = _ref13.type, roomType = _ref13.roomType, page = _ref13.page, limit = _ref13.limit;
                url = 'api/v2/sdk/search';
                isValidRoomType = ['group', 'single', 'channel'].some(function (it) {
                  return it === roomType;
                });

                if (!(roomType != null && !isValidRoomType)) {
                  _context17.next = 5;
                  break;
                }

                return _context17.abrupt("return", Promise.reject('Invalid room type, valid room type are: `group`, `single`, and `channel`'));

              case 5:
                room = function (roomType) {
                  var rType = roomType == null ? undefined : roomType === 'single' ? 'single' : 'group';
                  var isPublic = roomType == null ? undefined : roomType === 'channel' ? true : false;
                  return {
                    type: rType,
                    isPublic: isPublic
                  };
                }(roomType);

                return _context17.abrupt("return", this.HTTPAdapter.post_json(url, {
                  token: this.token,
                  query: query,
                  sender: userId,
                  type: type,
                  room_ids: roomIds.map(function (it) {
                    return String(it);
                  }),
                  room_type: room.type || undefined,
                  is_public: room.isPublic || undefined,
                  page: page,
                  limit: limit
                }).then(function (res) {
                  return res.body;
                }));

              case 7:
              case "end":
                return _context17.stop();
            }
          }
        }, _callee17, this);
      }));

      function searchMessage() {
        return _searchMessage.apply(this, arguments);
      }

      return searchMessage;
    }()
    /**
     * @typedef {Object} GetFileListParams
     * @property {Array.<number>} roomIds
     * @property {String} fileType
     * @property {Number} page
     * @property {Number} limit
     * @property {String} includeExtensions
     * @property {String} excludeExtensions
     * @property {String} userId
     */

    /**
     * @param {GetFileListParams} param0
     */

  }, {
    key: "getFileList",
    value: function () {
      var _getFileList = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee18() {
        var _ref14,
            _ref14$roomIds,
            roomIds,
            fileType,
            page,
            limit,
            sender,
            userId,
            includeExtensions,
            excludeExtensions,
            url,
            opts,
            _args18 = arguments;

        return _regenerator["default"].wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _ref14 = _args18.length > 0 && _args18[0] !== undefined ? _args18[0] : {}, _ref14$roomIds = _ref14.roomIds, roomIds = _ref14$roomIds === void 0 ? [] : _ref14$roomIds, fileType = _ref14.fileType, page = _ref14.page, limit = _ref14.limit, sender = _ref14.sender, userId = _ref14.userId, includeExtensions = _ref14.includeExtensions, excludeExtensions = _ref14.excludeExtensions;
                url = 'api/v2/sdk/file_list';

                if (this.isLogin) {
                  _context18.next = 4;
                  break;
                }

                return _context18.abrupt("return", Promise.reject('You need to login to use this method'));

              case 4:
                // intended to check for undefined, so user can provide user
                // with null. If null, backend can determine that we want to
                // list files for all users
                if (sender === undefined) {
                  sender = this.user_id;
                }

                if (userId === undefined) {
                  sender = userId = this.user_id;
                }

                opts = {
                  room_ids: roomIds.map(function (it) {
                    return String(it);
                  }),
                  file_type: fileType,
                  page: page,
                  limit: limit,
                  include_extensions: includeExtensions,
                  exclude_extensions: excludeExtensions
                };
                if (sender != null) opts['sender'] = sender;
                return _context18.abrupt("return", this.HTTPAdapter.post_json(url, opts).then(function (res) {
                  return res.body;
                }));

              case 9:
              case "end":
                return _context18.stop();
            }
          }
        }, _callee18, this);
      }));

      function getFileList() {
        return _getFileList.apply(this, arguments);
      }

      return getFileList;
    }()
  }, {
    key: "_generateUniqueId",
    value: function _generateUniqueId() {
      return "javascript-".concat(Date.now());
    }
  }, {
    key: "generateMessage",
    value: function generateMessage(_ref15) {
      var roomId = _ref15.roomId,
          text = _ref15.text,
          extras = _ref15.extras;
      var id = Date.now();
      var comment = new _Comment["default"]({
        id: id,
        message: text,
        room_id: roomId,
        extras: extras,
        timestamp: new Date(),
        unique_id: this._generateUniqueId(),
        before_id: 0,
        username: this.userData.username,
        email: this.userData.email,
        status: 'pending',
        type: 'text'
      });
      return comment;
    }
  }, {
    key: "generateFileAttachmentMessage",
    value: function generateFileAttachmentMessage(_ref16) {
      var roomId = _ref16.roomId,
          caption = _ref16.caption,
          url = _ref16.url,
          _ref16$text = _ref16.text,
          text = _ref16$text === void 0 ? 'File attachment' : _ref16$text,
          extras = _ref16.extras,
          filename = _ref16.filename,
          size = _ref16.size;
      var id = Date.now();
      var comment = new _Comment["default"]({
        id: id,
        message: text,
        room_id: roomId,
        extras: extras,
        timestamp: new Date(),
        unique_id: this._generateUniqueId(),
        before_id: 0,
        username: this.userData.username,
        email: this.userData.email,
        status: 'pending',
        type: 'file_attachment',
        payload: {
          url: url,
          file_name: filename,
          size: size,
          caption: caption
        }
      });
      return comment;
    }
  }, {
    key: "generateCustomMessage",
    value: function generateCustomMessage(_ref17) {
      var roomId = _ref17.roomId,
          text = _ref17.text,
          type = _ref17.type,
          payload = _ref17.payload,
          extras = _ref17.extras;
      var id = Date.now();
      var comment = new _Comment["default"]({
        id: id,
        message: text,
        room_id: roomId,
        extras: extras,
        timestamp: new Date(),
        unique_id: this._generateUniqueId(),
        before_id: 0,
        username: this.userData.username,
        email: this.userData.email,
        status: 'pending',
        type: 'custom',
        payload: {
          type: type,
          content: payload
        }
      });
      return comment;
    }
  }, {
    key: "generateReplyMessage",
    value: function generateReplyMessage(_ref18) {
      var roomId = _ref18.roomId,
          text = _ref18.text,
          repliedMessage = _ref18.repliedMessage,
          extras = _ref18.extras;
      var id = Date.now();
      var comment = new _Comment["default"]({
        id: id,
        message: text,
        room_id: roomId,
        extras: extras,
        timestamp: new Date(),
        unique_id: this._generateUniqueId(),
        before_id: 0,
        username: this.userData.username,
        email: this.userData.email,
        status: 'pending',
        type: 'reply',
        payload: {
          text: text,
          replied_comment_id: repliedMessage.id,
          replied_comment_message: repliedMessage.message,
          replied_comment_type: repliedMessage.type,
          replied_comment_payload: repliedMessage.payload,
          replied_comment_sender_username: repliedMessage.username_as,
          replied_comment_sender_email: repliedMessage.username_real
        }
      });
      return comment;
    }
  }, {
    key: "updateMessage",
    value: function () {
      var _updateMessage = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee19(message) {
        return _regenerator["default"].wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                return _context19.abrupt("return", this.userAdapter.updateMessage(message));

              case 1:
              case "end":
                return _context19.stop();
            }
          }
        }, _callee19, this);
      }));

      function updateMessage(_x16) {
        return _updateMessage.apply(this, arguments);
      }

      return updateMessage;
    }()
  }, {
    key: "onMessageUpdated",
    value: function onMessageUpdated(handler) {
      var _this18 = this;

      this.realtimeAdapter.on('message:updated', handler);
      return function () {
        return _this18.realtimeAdapter.off('message:updated', handler);
      };
    }
    /**
     * Manually close connection to mqtt server
     * @return {Promise<boolean>} Wheter successfully close mqtt connection or not
     */

  }, {
    key: "closeRealtimeConnection",
    value: function () {
      var _closeRealtimeConnection = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee20() {
        return _regenerator["default"].wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                return _context20.abrupt("return", this.realtimeAdapter.closeConnection());

              case 1:
              case "end":
                return _context20.stop();
            }
          }
        }, _callee20, this);
      }));

      function closeRealtimeConnection() {
        return _closeRealtimeConnection.apply(this, arguments);
      }

      return closeRealtimeConnection;
    }()
    /**
     * Manually open connection to mqtt server
     * @return {Promise<boolean>} Wheter successfully connect to mqtt server or not
     */

  }, {
    key: "openRealtimeConnection",
    value: function () {
      var _openRealtimeConnection = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee21() {
        return _regenerator["default"].wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                return _context21.abrupt("return", this.realtimeAdapter.openConnection());

              case 1:
              case "end":
                return _context21.stop();
            }
          }
        }, _callee21, this);
      }));

      function openRealtimeConnection() {
        return _openRealtimeConnection.apply(this, arguments);
      }

      return openRealtimeConnection;
    }()
  }, {
    key: "startSync",
    value: function () {
      var _startSync = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee22() {
        return _regenerator["default"].wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                this._forceEnableSync = true;

              case 1:
              case "end":
                return _context22.stop();
            }
          }
        }, _callee22, this);
      }));

      function startSync() {
        return _startSync.apply(this, arguments);
      }

      return startSync;
    }()
  }, {
    key: "stopSync",
    value: function () {
      var _stopSync = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee23() {
        return _regenerator["default"].wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                this._forceEnableSync = false;

              case 1:
              case "end":
                return _context23.stop();
            }
          }
        }, _callee23, this);
      }));

      function stopSync() {
        return _stopSync.apply(this, arguments);
      }

      return stopSync;
    }()
  }, {
    key: "uploadURL",
    get: function get() {
      return this._uploadURL || "".concat(this.baseURL, "/api/v2/sdk/upload");
    },
    set: function set(uploadURL) {
      this._uploadURL = uploadURL;
    }
  }, {
    key: "synchronize",
    get: function get() {
      return this.syncAdapter.synchronize;
    }
  }, {
    key: "synchronizeEvent",
    get: function get() {
      return this.syncAdapter.synchronizeEvent;
    }
  }, {
    key: "Interceptor",
    get: function get() {
      return _hook.Hooks;
    }
  }, {
    key: "logger",
    get: function get() {
      if (this.debugMode) return console.log.bind(console, 'Qiscus ->');
      return this.noop;
    }
  }, {
    key: "_throttleDelay",
    get: function get() {
      if (this.updateCommentStatusMode === QiscusSDK.UpdateCommentStatusMode.enabled) {
        return 0;
      }

      return this.updateCommentStatusThrottleDelay || 300;
    }
  }, {
    key: "_updateStatusEnabled",
    get: function get() {
      return this.updateCommentStatusMode !== QiscusSDK.UpdateCommentStatusMode.disabled;
    }
  }]);
  return QiscusSDK;
}();

(0, _defineProperty2["default"])(QiscusSDK, "UpdateCommentStatusMode", UpdateCommentStatusMode);
(0, _defineProperty2["default"])(QiscusSDK, "Interceptor", _hook.Hooks);

var FileUploaded = function FileUploaded(name, roomId) {
  (0, _classCallCheck2["default"])(this, FileUploaded);
  this.name = name;
  this.roomId = roomId;
  this.progress = 0;
};

var _default = QiscusSDK;
exports["default"] = _default;
module.exports = exports.default;