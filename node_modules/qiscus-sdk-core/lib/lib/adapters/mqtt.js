"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));

var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _match2 = require("../match");

var _mitt = _interopRequireDefault(require("mitt"));

var _connect = _interopRequireDefault(require("mqtt/lib/connect"));

var _superagent = _interopRequireDefault(require("superagent"));

var _lodash = _interopRequireDefault(require("lodash.debounce"));

var _util = require("../util");

var MqttAdapter = /*#__PURE__*/function () {
  /**
   * @typedef {Function} GetClientId
   * @return {string}
   */

  /**
   * @typedef {Object} MqttAdapterParams
   * @property {boolean} shouldConnect
   * @property {string} brokerLbUrl
   * @property {boolean} enableLb
   * @property {GetClientId} getClientId
   */

  /**
   * @param {string} url
   * @param {QiscusSDK} core
   * @param {boolean} login
   * @param {MqttAdapterParams} obj
   */
  function MqttAdapter(_url, core, login, _ref) {
    var _this = this,
        _match;

    var _ref$shouldConnect = _ref.shouldConnect,
        shouldConnect = _ref$shouldConnect === void 0 ? true : _ref$shouldConnect,
        brokerLbUrl = _ref.brokerLbUrl,
        enableLb = _ref.enableLb,
        getClientId = _ref.getClientId;
    (0, _classCallCheck2["default"])(this, MqttAdapter);
    (0, _defineProperty2["default"])(this, "_getClientId", function () {
      if (_this.getClientId == null) return "".concat(_this.core.AppId, "_").concat(_this.core.user_id, "_").concat(Date.now());
      return _this.getClientId();
    });
    (0, _defineProperty2["default"])(this, "__mqtt_connected_handler", function () {
      _this.emitter.emit('connected');
    });
    (0, _defineProperty2["default"])(this, "__mqtt_reconnect_handler", function () {
      _this.emitter.emit('reconnect');
    });
    (0, _defineProperty2["default"])(this, "__mqtt_closed_handler", function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this.emitter.emit('close', args);
    });
    (0, _defineProperty2["default"])(this, "__mqtt_message_handler", function (t, m) {
      var message = m.toString();

      var func = _this.matcher(t);

      _this.logger('message', t, m);

      if (func != null) func(message);
    });
    (0, _defineProperty2["default"])(this, "__mqtt_error_handler", function (err) {
      if (err && err.message === 'client disconnecting') return;

      _this.emitter.emit('error', err.message);

      _this.logger('error', err.message);
    });
    (0, _defineProperty2["default"])(this, "__mqtt_conneck", function (brokerUrl) {
      var topics = [];
      var opts = {
        will: {
          topic: "u/".concat(_this.core.user_id, "/s"),
          payload: 0,
          retain: true
        },
        clientId: _this._getClientId() // reconnectPeriod: 0,
        // connectTimeout: 1 * 1000,

      };
      if (brokerUrl == null) brokerUrl = _this.cacheRealtimeURL;

      if (_this.mqtt != null) {
        var _topics = Object.keys(_this.mqtt._resubscribeTopics);

        topics.push.apply(topics, (0, _toConsumableArray2["default"])(_topics));

        _this.mqtt.removeAllListeners();

        _this.mqtt.end(true);

        delete _this.mqtt;
        _this.mqtt = null;
      }

      var mqtt = (0, _connect["default"])(brokerUrl, opts); // #region Mqtt Listener

      mqtt.addListener('connect', _this.__mqtt_connected_handler);
      mqtt.addListener('reconnect', _this.__mqtt_reconnect_handler);
      mqtt.addListener('close', _this.__mqtt_closed_handler);
      mqtt.addListener('error', _this.__mqtt_error_handler);
      mqtt.addListener('message', _this.__mqtt_message_handler); // #endregion

      _this.logger("resubscribe to old topics ".concat(topics));

      topics.forEach(function (topic) {
        return mqtt.subscribe(topic);
      });
      return mqtt;
    });
    (0, _defineProperty2["default"])(this, "_on_close_handler", (0, _lodash["default"])( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
      var shouldReconnect, _yield$wrapP, _yield$wrapP2, url, err;

      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              shouldReconnect = _this.enableLb === true && // appConfig enabling realtime lb
              _this.core.isLogin === true && // is logged in
              _this.shouldConnect === true && // should reconnect?
              !_this.willConnectToRealtime; // is there still reconnect process in progress?

              if (_this.logEnabled) {
                console.group('@mqtt.closed');
                console.log("this.enableLb(".concat(_this.enableLb, ")"));
                console.log("this.core.isLogin(".concat(_this.core.isLogin, ")"));
                console.log("this.shouldConnect(".concat(_this.shouldConnect, ")"));
                console.log("this.willConnectToRealtime(".concat(_this.willConnectToRealtime, ")"));
                console.log("shouldReconnect(".concat(shouldReconnect, ")"));
                console.groupEnd();
              }

              if (shouldReconnect) {
                _context.next = 4;
                break;
              }

              return _context.abrupt("return");

            case 4:
              _this.willConnectToRealtime = true;
              _context.next = 7;
              return (0, _util.wrapP)(_this.getMqttNode());

            case 7:
              _yield$wrapP = _context.sent;
              _yield$wrapP2 = (0, _slicedToArray2["default"])(_yield$wrapP, 2);
              url = _yield$wrapP2[0];
              err = _yield$wrapP2[1];

              if (err) {
                _this.logger("cannot get new brokerURL, using old url instead (".concat(_this.cacheRealtimeURL, ")"));

                _this.mqtt = _this.__mqtt_conneck(_this.cacheRealtimeURL);
              } else {
                _this.cacheRealtimeURL = url;

                _this.logger('trying to reconnect to', url);

                _this.mqtt = _this.__mqtt_conneck(url);
              }

              _this.willConnectToRealtime = false;

            case 13:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    })), 1000));
    (0, _defineProperty2["default"])(this, "subscribtionBuffer", []);
    (0, _defineProperty2["default"])(this, "unsubscribtionBuffer", []);
    (0, _defineProperty2["default"])(this, "publishBuffer", []);
    this.emitter = (0, _mitt["default"])();
    this.core = core;
    this.mqtt = null;
    this.brokerLbUrl = brokerLbUrl;
    this.getClientId = getClientId;
    this.enableLb = enableLb;
    this.shouldConnect = shouldConnect;
    this.matcher = (0, _match2.match)((_match = {}, (0, _defineProperty2["default"])(_match, (0, _match2.when)(this.reNewMessage), function (topic) {
      return _this.newMessageHandler.bind(_this, topic);
    }), (0, _defineProperty2["default"])(_match, (0, _match2.when)(this.reNotification), function (topic) {
      return _this.notificationHandler.bind(_this, topic);
    }), (0, _defineProperty2["default"])(_match, (0, _match2.when)(this.reTyping), function (topic) {
      return _this.typingHandler.bind(_this, topic);
    }), (0, _defineProperty2["default"])(_match, (0, _match2.when)(this.reDelivery), function (topic) {
      return _this.deliveryReceiptHandler.bind(_this, topic);
    }), (0, _defineProperty2["default"])(_match, (0, _match2.when)(this.reRead), function (topic) {
      return _this.readReceiptHandler.bind(_this, topic);
    }), (0, _defineProperty2["default"])(_match, (0, _match2.when)(this.reOnlineStatus), function (topic) {
      return _this.onlinePresenceHandler.bind(_this, topic);
    }), (0, _defineProperty2["default"])(_match, (0, _match2.when)(this.reChannelMessage), function (topic) {
      return _this.channelMessageHandler.bind(_this, topic);
    }), (0, _defineProperty2["default"])(_match, (0, _match2.when)(this.reMessageUpdated), function (topic) {
      return _this.messageUpdatedHandler.bind(_this, topic);
    }), (0, _defineProperty2["default"])(_match, (0, _match2.when)(), function (topic) {
      return _this.logger('topic not handled', topic);
    }), _match));

    var _mqtt = this.__mqtt_conneck(_url);

    this.mqtt = _mqtt; // if appConfig set realtimeEnabled to false,
    // we intentionally end mqtt connection here.
    // TODO: Make a better way to not connect
    //       to broker, but still having mqtt client initiated.

    if (!shouldConnect) _mqtt.end(true);
    this.willConnectToRealtime = false; // handle load balencer

    this.emitter.on('close', this._on_close_handler); // this.emitter.on('connected', () => {
    //   this.willConnectToRealtime = false
    // })
  }

  (0, _createClass2["default"])(MqttAdapter, [{
    key: "connect",
    value: function connect() {
      this.mqtt = this.__mqtt_conneck();
    }
    /**
     * @return {Promise<boolean}
     */

  }, {
    key: "openConnection",
    value: function () {
      var _openConnection = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
        return _regenerator["default"].wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.shouldConnect = true;

                this.__mqtt_conneck();

              case 2:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function openConnection() {
        return _openConnection.apply(this, arguments);
      }

      return openConnection;
    }()
    /**
     * @return {Promise<boolean>}
     */

  }, {
    key: "closeConnection",
    value: function () {
      var _closeConnection = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
        return _regenerator["default"].wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                this.shouldConnect = false;
                this.mqtt.end(true);

              case 2:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function closeConnection() {
        return _closeConnection.apply(this, arguments);
      }

      return closeConnection;
    }()
  }, {
    key: "getMqttNode",
    value: function () {
      var _getMqttNode = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
        var res, url, port;
        return _regenerator["default"].wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                _context4.next = 2;
                return _superagent["default"].get(this.brokerLbUrl);

              case 2:
                res = _context4.sent;
                url = res.body.data.url;
                port = res.body.data.wss_port;
                return _context4.abrupt("return", "wss://".concat(url, ":").concat(port, "/mqtt"));

              case 6:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function getMqttNode() {
        return _getMqttNode.apply(this, arguments);
      }

      return getMqttNode;
    }()
  }, {
    key: "subscribe",
    value: function subscribe() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      this.logger('subscribe to', args);
      this.subscribtionBuffer.push(args);

      if (this.mqtt != null) {
        do {
          var _this$mqtt;

          var subs = this.subscribtionBuffer.shift();
          if (subs != null) (_this$mqtt = this.mqtt).subscribe.apply(_this$mqtt, args);
        } while (this.subscribtionBuffer.length > 0);
      }
    }
  }, {
    key: "unsubscribe",
    value: function unsubscribe() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      this.logger('unsubscribe from', args);
      this.unsubscribtionBuffer.push(args);

      if (this.mqtt != null) {
        do {
          var subs = this.unsubscribtionBuffer.shift();

          if (subs != null) {
            var _this$mqtt2;

            (_this$mqtt2 = this.mqtt).unsubscribe.apply(_this$mqtt2, (0, _toConsumableArray2["default"])(subs));
          }
        } while (this.unsubscribtionBuffer.length > 0);
      }
    }
  }, {
    key: "publish",
    value: function publish(topic, payload) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      this.publishBuffer.push({
        topic: topic,
        payload: payload,
        options: options
      });

      do {
        var data = this.publishBuffer.shift();

        if (data != null) {
          return this.mqtt.publish(data.topic, data.payload.toString(), data.options);
        }
      } while (this.publishBuffer.length > 0);
    }
  }, {
    key: "emit",
    value: function emit() {
      var _this$emitter;

      (_this$emitter = this.emitter).emit.apply(_this$emitter, arguments);
    }
  }, {
    key: "on",
    value: function on() {
      var _this$emitter2;

      (_this$emitter2 = this.emitter).on.apply(_this$emitter2, arguments);
    }
  }, {
    key: "off",
    value: function off() {
      var _this$emitter3;

      (_this$emitter3 = this.emitter).off.apply(_this$emitter3, arguments);
    }
  }, {
    key: "noop",
    // #endregion
    value: function noop() {}
  }, {
    key: "newMessageHandler",
    value: function newMessageHandler(topic, message) {
      message = JSON.parse(message);
      this.logger('on:new-message', message);
      this.emit('new-message', message);
    }
  }, {
    key: "notificationHandler",
    value: function notificationHandler(topic, message) {
      var _this2 = this;

      this.logger('on:notification', message);
      message = JSON.parse(message);
      var data = message.payload.data;

      if ('deleted_messages' in data) {
        data.deleted_messages.forEach(function (message) {
          _this2.emit('comment-deleted', {
            roomId: message.room_id,
            commentUniqueIds: message.message_unique_ids,
            isForEveryone: true,
            isHard: true
          });
        });
      }

      if ('deleted_rooms' in data) {
        data.deleted_rooms.forEach(function (room) {
          _this2.emit('room-cleared', room);
        });
      }
    }
  }, {
    key: "typingHandler",
    value: function typingHandler(t, message) {
      this.logger('on:typing', t); // r/{roomId}/{roomId}/{userId}/t

      var topic = t.match(this.reTyping);
      if (topic[3] === this.core.user_id) return;
      var userId = topic[3];
      var roomId = topic[1];
      this.emit('typing', {
        message: message,
        userId: userId,
        roomId: roomId
      }); // TODO: Don't allow side-effect
      // it should be handled in the UI not core

      if (this.core.selected == null) return;

      if (message === '1' && roomId === this.core.selected.id) {
        var actor = this.core.selected.participants.find(function (it) {
          return it.email === userId;
        });
        if (actor == null) return;
        var displayName = actor.username;
        this.core.isTypingStatus = "".concat(displayName, " is typing ...");
      } else {
        this.core.isTypingStatus = null;
      }
    }
  }, {
    key: "deliveryReceiptHandler",
    value: function deliveryReceiptHandler(t, message) {
      this.logger('on:delivered', t, message); // r/{roomId}/{roomId}/{userId}/d

      var topic = t.match(this.reDelivery);
      var data = message.split(':');
      var commentId = Number(data[0]);
      var commentUniqueId = data[1];
      var userId = topic[3];
      this.emit('message-delivered', {
        commentId: commentId,
        commentUniqueId: commentUniqueId,
        userId: userId
      });
    }
  }, {
    key: "readReceiptHandler",
    value: function readReceiptHandler(t, message) {
      this.logger('on:read', t, message); // r/{roomId}/{roomId}/{userId}/r

      var topic = t.match(this.reRead);
      var data = message.split(':');
      var commentId = Number(data[0]);
      var commentUniqueId = data[1];
      var userId = topic[3];
      this.emit('message-read', {
        commentId: commentId,
        commentUniqueId: commentUniqueId,
        userId: userId
      });
    }
  }, {
    key: "onlinePresenceHandler",
    value: function onlinePresenceHandler(topic, message) {
      this.logger('on:online-presence', topic, message); // u/guest-1002/s

      var topicData = this.reOnlineStatus.exec(topic);
      var userId = topicData[1];
      this.emit('presence', {
        message: message,
        userId: userId
      });
    }
  }, {
    key: "channelMessageHandler",
    value: function channelMessageHandler(topic, message) {
      this.logger('on:channel-message', topic, message);
      this.emit('new-message', JSON.parse(message));
    }
  }, {
    key: "messageUpdatedHandler",
    value: function messageUpdatedHandler(topic, message) {
      message = JSON.parse(message);
      this.logger('on:message-updated', topic, message);
      this.emit('message:updated', message);
    } // #region old-methods

  }, {
    key: "subscribeChannel",
    value: function subscribeChannel(appId, uniqueId) {
      this.subscribe("".concat(appId, "/").concat(uniqueId, "/c"));
    }
  }, {
    key: "subscribeRoom",
    value: function subscribeRoom(roomId) {
      if (this.core.selected == null) return;
      roomId = roomId || this.core.selected.id;
      this.subscribe("r/".concat(roomId, "/").concat(roomId, "/+/t"));
      this.subscribe("r/".concat(roomId, "/").concat(roomId, "/+/d"));
      this.subscribe("r/".concat(roomId, "/").concat(roomId, "/+/r"));
    }
  }, {
    key: "unsubscribeRoom",
    value: function unsubscribeRoom(roomId) {
      if (this.core.selected == null) return;
      roomId = roomId || this.core.selected.id;
      this.unsubscribe("r/".concat(roomId, "/").concat(roomId, "/+/t"));
      this.unsubscribe("r/".concat(roomId, "/").concat(roomId, "/+/d"));
      this.unsubscribe("r/".concat(roomId, "/").concat(roomId, "/+/r"));
    }
  }, {
    key: "subscribeUserChannel",
    value: function subscribeUserChannel() {
      this.subscribe("".concat(this.core.userData.token, "/c"));
      this.subscribe("".concat(this.core.userData.token, "/n"));
      this.subscribe("".concat(this.core.userData.token, "/update"));
    }
  }, {
    key: "publishPresence",
    value: function publishPresence(userId) {
      var isOnline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      isOnline ? this.publish("u/".concat(userId, "/s"), 1, {
        retain: true
      }) : this.publish("u/".concat(userId, "/s"), 0, {
        retain: true
      });
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      this.publishPresence(this.core.userData.email, false);
      this.unsubscribe(Object.keys(this.mqtt._resubscribeTopics));
    }
  }, {
    key: "subscribeUserPresence",
    value: function subscribeUserPresence(userId) {
      this.subscribe("u/".concat(userId, "/s"));
    }
  }, {
    key: "unsubscribeUserPresence",
    value: function unsubscribeUserPresence(userId) {
      this.unsubscribe("u/".concat(userId, "/s"));
    }
  }, {
    key: "publishTyping",
    value: function publishTyping(status) {
      if (this.core.selected == null) return;
      var roomId = this.core.selected.id;
      var userId = this.core.user_id;
      this.publish("r/".concat(roomId, "/").concat(roomId, "/").concat(userId, "/t"), status);
    } // #endregion

  }, {
    key: "cacheRealtimeURL",
    get: function get() {
      return this.core.mqttURL;
    },
    set: function set(url) {
      this.core.mqttURL = url;
    }
  }, {
    key: "connected",
    get: function get() {
      if (this.mqtt == null) return false;
      return this.mqtt.connected;
    }
  }, {
    key: "logEnabled",
    get: function get() {
      return this.core.debugMQTTMode;
    }
  }, {
    key: "logger",
    get: function get() {
      if (!this.core.debugMQTTMode) return this.noop;
      return console.log.bind(console, 'QRealtime ->');
    } // #region regexp

  }, {
    key: "reNewMessage",
    get: function get() {
      return /^(.+)\/c$/i;
    }
  }, {
    key: "reNotification",
    get: function get() {
      return /^(.+)\/n$/i;
    }
  }, {
    key: "reTyping",
    get: function get() {
      return /^r\/([\d]+)\/([\d]+)\/(.+)\/t$/i;
    }
  }, {
    key: "reDelivery",
    get: function get() {
      return /^r\/([\d]+)\/([\d]+)\/(.+)\/d$/i;
    }
  }, {
    key: "reRead",
    get: function get() {
      return /^r\/([\d]+)\/([\d]+)\/(.+)\/r$/i;
    }
  }, {
    key: "reOnlineStatus",
    get: function get() {
      return /^u\/(.+)\/s$/i;
    }
  }, {
    key: "reChannelMessage",
    get: function get() {
      return /^(.+)\/(.+)\/c$/i;
    }
  }, {
    key: "reMessageUpdated",
    get: function get() {
      return /^(.+)\/update$/i;
    }
  }, {
    key: "subscribeTyping",
    get: function get() {
      return this.subscribeRoom.bind(this);
    }
  }, {
    key: "unsubscribeTyping",
    get: function get() {
      return this.unsubscribeRoom.bind(this);
    }
  }, {
    key: "subscribeRoomPresence",
    get: function get() {
      return this.subscribeUserPresence.bind(this);
    }
  }, {
    key: "unsubscribeRoomPresence",
    get: function get() {
      return this.unsubscribeUserPresence.bind(this);
    }
  }]);
  return MqttAdapter;
}();

exports["default"] = MqttAdapter;
module.exports = exports.default;